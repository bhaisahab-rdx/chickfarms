var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// server/index.ts
import express3 from "express";

// server/auth.ts
import passport from "passport";
import { Strategy as LocalStrategy } from "passport-local";
import session2 from "express-session";

// server/storage.ts
import { eq, and, desc, sql } from "drizzle-orm";

// server/db.ts
import pkg from "pg";
import { drizzle } from "drizzle-orm/node-postgres";

// shared/schema.ts
var schema_exports = {};
__export(schema_exports, {
  CHICKEN_LIFESPAN: () => CHICKEN_LIFESPAN,
  DEFAULT_ACHIEVEMENT_BADGES: () => DEFAULT_ACHIEVEMENT_BADGES,
  DEFAULT_PRICES: () => DEFAULT_PRICES,
  SALARY_PER_REFERRAL: () => SALARY_PER_REFERRAL,
  achievementBadges: () => achievementBadges,
  activeBoosts: () => activeBoosts,
  boostTypes: () => boostTypes,
  chickens: () => chickens,
  dailyRewards: () => dailyRewards,
  dailyRewardsByDay: () => dailyRewardsByDay,
  dailySpinRewards: () => dailySpinRewards,
  gameSettings: () => gameSettings,
  initializeDefaultsQuery: () => initializeDefaultsQuery,
  insertAchievementBadgeSchema: () => insertAchievementBadgeSchema,
  insertActiveBoostSchema: () => insertActiveBoostSchema,
  insertChickenSchema: () => insertChickenSchema,
  insertDailyRewardSchema: () => insertDailyRewardSchema,
  insertGameSettingSchema: () => insertGameSettingSchema,
  insertMilestoneRewardSchema: () => insertMilestoneRewardSchema,
  insertMysteryBoxRewardSchema: () => insertMysteryBoxRewardSchema,
  insertPriceSchema: () => insertPriceSchema,
  insertReferralEarningSchema: () => insertReferralEarningSchema,
  insertResourceSchema: () => insertResourceSchema,
  insertSalaryPaymentSchema: () => insertSalaryPaymentSchema,
  insertSpinHistorySchema: () => insertSpinHistorySchema,
  insertSpinRewardSchema: () => insertSpinRewardSchema,
  insertTransactionSchema: () => insertTransactionSchema,
  insertUserAchievementSchema: () => insertUserAchievementSchema,
  insertUserProfileSchema: () => insertUserProfileSchema,
  insertUserSchema: () => insertUserSchema,
  milestoneRewards: () => milestoneRewards,
  milestoneThresholds: () => milestoneThresholds,
  mysteryBoxRewards: () => mysteryBoxRewards,
  mysteryBoxTypes: () => mysteryBoxTypes,
  possibleMysteryBoxRewards: () => possibleMysteryBoxRewards,
  prices: () => prices,
  referralCommissionRates: () => referralCommissionRates,
  referralEarnings: () => referralEarnings,
  resources: () => resources,
  salaryPayments: () => salaryPayments,
  spinHistory: () => spinHistory,
  spinRewards: () => spinRewards,
  superJackpotRewards: () => superJackpotRewards,
  transactions: () => transactions,
  userAchievements: () => userAchievements,
  userProfiles: () => userProfiles,
  users: () => users
});
import { pgTable, text, serial, integer, boolean, timestamp, decimal, jsonb, date } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";
var dailySpinRewards = [
  { reward: { type: "eggs", amount: 5 }, probability: 25 },
  { reward: { type: "eggs", amount: 10 }, probability: 20 },
  { reward: { type: "eggs", amount: 15 }, probability: 15 },
  { reward: { type: "wheat", amount: 5 }, probability: 15 },
  { reward: { type: "water", amount: 5 }, probability: 15 },
  { reward: { type: "extra_spin", amount: 1 }, probability: 5 },
  { reward: { type: "usdt", amount: 0.5 }, probability: 4 },
  { reward: { type: "usdt", amount: 1 }, probability: 1 }
];
var superJackpotRewards = [
  { reward: { type: "eggs", amount: 50 }, probability: 30 },
  { reward: { type: "eggs", amount: 100 }, probability: 20 },
  { reward: { type: "eggs", amount: 200 }, probability: 15 },
  { reward: { type: "usdt", amount: 5 }, probability: 10 },
  { reward: { type: "chicken", amount: 1, chickenType: "regular" }, probability: 10 },
  { reward: { type: "chicken", amount: 1, chickenType: "golden" }, probability: 5 },
  { reward: { type: "usdt", amount: 25 }, probability: 3 },
  { reward: { type: "usdt", amount: 50 }, probability: 2 },
  {
    reward: {
      type: "chicken",
      amount: 1,
      chickenType: "golden"
    },
    probability: 1
  }
];
var mysteryBoxTypes = {
  basic: {
    price: 10,
    name: "Basic Box",
    description: "A starter mystery box with common resources",
    rewards: {
      resources: {
        wheat: {
          ranges: [
            { min: 10, max: 50, chance: 0.4 },
            // 40% chance
            { min: 5, max: 20, chance: 0.3 }
            // 30% chance
          ]
        },
        water: {
          ranges: [
            { min: 5, max: 20, chance: 0.4 },
            // 40% chance
            { min: 3, max: 10, chance: 0.3 }
            // 30% chance
          ]
        }
      },
      eggs: {
        ranges: [
          { min: 1, max: 5, chance: 0.3 }
          // 30% chance
        ]
      }
    },
    rarityDistribution: {
      common: 0.7,
      // 70% chance
      rare: 0.3
      // 30% chance
    }
  },
  silver: {
    price: 25,
    name: "Silver Box",
    description: "Enhanced rewards with chance for a baby chicken",
    rewards: {
      resources: {
        wheat: {
          ranges: [
            { min: 50, max: 150, chance: 0.35 },
            // 35% chance
            { min: 25, max: 75, chance: 0.25 }
            // 25% chance
          ]
        },
        water: {
          ranges: [
            { min: 20, max: 50, chance: 0.35 },
            // 35% chance
            { min: 10, max: 25, chance: 0.25 }
            // 25% chance
          ]
        }
      },
      eggs: {
        ranges: [
          { min: 5, max: 15, chance: 0.2 }
          // 20% chance
        ]
      },
      chicken: {
        types: ["baby"],
        chance: 0.1
        // 10% chance
      }
    },
    rarityDistribution: {
      common: 0.5,
      // 50% chance
      rare: 0.4,
      // 40% chance
      epic: 0.1
      // 10% chance
    }
  },
  golden: {
    price: 50,
    name: "Golden Box",
    description: "Premium rewards with guaranteed resources and high-value items",
    rewards: {
      resources: {
        wheat: {
          ranges: [
            { min: 150, max: 300, chance: 0.3 },
            // 30% chance
            { min: 75, max: 150, chance: 0.3 }
            // 30% chance
          ]
        },
        water: {
          ranges: [
            { min: 50, max: 100, chance: 0.3 },
            // 30% chance
            { min: 25, max: 50, chance: 0.3 }
            // 30% chance
          ]
        }
      },
      eggs: {
        ranges: [
          { min: 15, max: 30, chance: 0.2 }
          // 20% chance
        ]
      },
      chicken: {
        types: ["regular"],
        chance: 0.15
        // 15% chance
      },
      usdt: {
        ranges: [
          { amount: 5, chance: 0.05 }
          // 5% USDT bonus
        ]
      }
    },
    rarityDistribution: {
      common: 0.3,
      // 30% chance
      rare: 0.4,
      // 40% chance
      epic: 0.2,
      // 20% chance
      legendary: 0.1
      // 10% chance
    }
  },
  diamond: {
    price: 100,
    name: "Diamond Box",
    description: "Legendary box with the highest value rewards",
    rewards: {
      resources: {
        wheat: {
          ranges: [
            { min: 300, max: 500, chance: 0.25 },
            // 25% chance
            { min: 150, max: 300, chance: 0.25 }
            // 25% chance
          ]
        },
        water: {
          ranges: [
            { min: 100, max: 200, chance: 0.25 },
            // 25% chance
            { min: 50, max: 100, chance: 0.25 }
            // 25% chance
          ]
        }
      },
      eggs: {
        ranges: [
          { min: 30, max: 50, chance: 0.2 }
          // 20% chance
        ]
      },
      chicken: {
        types: ["golden"],
        chance: 0.2
        // 20% chance
      },
      usdt: {
        ranges: [
          { amount: 10, chance: 0.1 }
          // 10% USDT bonus
        ]
      }
    },
    rarityDistribution: {
      rare: 0.3,
      // 30% chance
      epic: 0.5,
      // 50% chance
      legendary: 0.2
      // 20% chance
    }
  }
};
var users = pgTable("users", {
  id: serial("id").primaryKey(),
  username: text("username").notNull().unique(),
  password: text("password").notNull(),
  usdtBalance: decimal("usdt_balance", { precision: 10, scale: 2 }).notNull().default("0"),
  referralCode: text("referral_code").notNull().unique(),
  referredBy: text("referred_by"),
  isAdmin: boolean("is_admin").notNull().default(false),
  lastLoginAt: timestamp("last_login_at"),
  totalReferralEarnings: decimal("total_referral_earnings", { precision: 10, scale: 2 }).notNull().default("0"),
  totalTeamEarnings: decimal("total_team_earnings", { precision: 10, scale: 2 }).notNull().default("0"),
  lastSalaryPaidAt: timestamp("last_salary_paid_at"),
  lastDailyRewardAt: date("last_daily_reward_at"),
  currentStreak: integer("current_streak").notNull().default(0),
  lastSpinAt: timestamp("last_spin_at"),
  extraSpinsAvailable: integer("extra_spins_available").notNull().default(0),
  referralCount: integer("referral_count").notNull().default(0),
  telegramId: text("telegram_id")
  // Store user's Telegram ID for notifications
});
var CHICKEN_LIFESPAN = {
  baby: 40 * 24 * 60 * 60 * 1e3,
  // 40 days in milliseconds
  regular: null,
  // Unlimited lifespan
  golden: null
  // Unlimited lifespan
};
var chickens = pgTable("chickens", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull(),
  type: text("type").notNull(),
  // baby, regular, golden
  lastHatchTime: timestamp("last_hatch_time"),
  createdAt: timestamp("created_at").notNull().defaultNow(),
  status: text("status").notNull().default("alive"),
  // alive or dead
  deathDate: timestamp("death_date")
  // Only for baby chickens that have died
});
var resources = pgTable("resources", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull(),
  waterBuckets: integer("water_buckets").notNull().default(0),
  wheatBags: integer("wheat_bags").notNull().default(0),
  eggs: integer("eggs").notNull().default(0),
  mysteryBoxes: integer("mystery_boxes").notNull().default(0)
});
var transactions = pgTable("transactions", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull(),
  type: text("type").notNull(),
  // recharge, withdrawal, purchase, commission, mystery_box
  amount: decimal("amount", { precision: 10, scale: 2 }).notNull(),
  status: text("status").notNull(),
  // pending, completed, rejected
  transactionId: text("transaction_id"),
  referralCommission: decimal("referral_commission", { precision: 10, scale: 2 }),
  createdAt: timestamp("created_at").notNull().defaultNow(),
  bankDetails: text("bank_details")
  // JSON string containing bank account details
});
var gameSettings = pgTable("game_settings", {
  id: serial("id").primaryKey(),
  settingKey: text("setting_key").notNull().unique(),
  settingValue: text("setting_value").notNull(),
  updatedAt: timestamp("updated_at").notNull().defaultNow()
});
var prices = pgTable("prices", {
  id: serial("id").primaryKey(),
  itemType: text("item_type").notNull().unique(),
  // chicken types, resources, eggs, mystery_box
  price: decimal("price", { precision: 10, scale: 2 }).notNull()
});
var mysteryBoxRewards = pgTable("mystery_box_rewards", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull(),
  boxType: text("box_type").notNull(),
  rewardType: text("reward_type").notNull(),
  // "resource", "chicken", "egg", "usdt"
  rewardDetails: jsonb("reward_details").notNull(),
  // Detailed reward information
  rarity: text("rarity").notNull(),
  // common, rare, epic, legendary
  opened: boolean("opened").notNull().default(false),
  createdAt: timestamp("created_at").notNull().defaultNow(),
  claimedAt: timestamp("claimed_at")
});
var userProfiles = pgTable("user_profiles", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().unique(),
  farmName: text("farm_name"),
  avatarColor: text("avatar_color").default("#6366F1"),
  // Default indigo color
  avatarStyle: text("avatar_style").default("default"),
  farmBackground: text("farm_background").default("default"),
  tutorialCompleted: boolean("tutorial_completed").notNull().default(false),
  tutorialStep: integer("tutorial_step").notNull().default(0),
  tutorialDisabled: boolean("tutorial_disabled").notNull().default(false),
  lastUpdated: timestamp("last_updated").notNull().defaultNow(),
  displayedBadgeId: integer("displayed_badge_id")
});
var referralEarnings = pgTable("referral_earnings", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull(),
  referredUserId: integer("referred_user_id").notNull(),
  level: integer("level").notNull(),
  // 1-6 levels
  amount: decimal("amount", { precision: 10, scale: 2 }).notNull(),
  claimed: boolean("claimed").notNull().default(false),
  createdAt: timestamp("created_at").notNull().defaultNow()
});
var milestoneRewards = pgTable("milestone_rewards", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull(),
  milestone: decimal("milestone", { precision: 10, scale: 2 }).notNull(),
  // $1000, $10000, etc.
  reward: decimal("reward", { precision: 10, scale: 2 }).notNull(),
  claimed: boolean("claimed").notNull().default(false),
  claimedAt: timestamp("claimed_at"),
  createdAt: timestamp("created_at").notNull().defaultNow()
});
var salaryPayments = pgTable("salary_payments", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull(),
  amount: decimal("amount", { precision: 10, scale: 2 }).notNull(),
  period: text("period").notNull(),
  // e.g., "2023-01"
  paidAt: timestamp("paid_at").notNull().defaultNow()
});
var dailyRewards = pgTable("daily_rewards", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull(),
  day: integer("day").notNull(),
  // 1-7 for the streak day
  eggs: integer("eggs").notNull().default(0),
  usdt: decimal("usdt", { precision: 10, scale: 2 }).default("0"),
  claimed: boolean("claimed").notNull().default(false),
  createdAt: timestamp("created_at").notNull().defaultNow()
});
var activeBoosts = pgTable("active_boosts", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull(),
  type: text("type").notNull(),
  // egg_production, etc.
  multiplier: decimal("multiplier", { precision: 4, scale: 2 }).notNull(),
  // 1.5, 2.0, etc.
  expiresAt: timestamp("expires_at").notNull(),
  createdAt: timestamp("created_at").notNull().defaultNow()
});
var spinHistory = pgTable("spin_history", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull(),
  spinType: text("spinType").notNull(),
  // "daily" or "super"
  rewardType: text("rewardType").notNull(),
  // "eggs", "wheat", "water", "usdt", "extra_spin", "chicken"
  rewardAmount: decimal("reward_amount", { precision: 10, scale: 2 }).notNull(),
  chickenType: text("chickenType"),
  // For chicken rewards
  createdAt: timestamp("created_at").notNull().defaultNow()
});
var spinRewards = pgTable("spin_rewards", {
  id: serial("id").primaryKey(),
  spinType: text("spinType").notNull(),
  // "daily" or "super"
  rewardType: text("rewardType").notNull(),
  // "eggs", "wheat", "water", "usdt", "extra_spin", "chicken"
  amount: decimal("amount", { precision: 10, scale: 2 }).notNull(),
  chickenType: text("chickenType"),
  // For chicken rewards (if applicable)
  probability: decimal("probability", { precision: 5, scale: 2 }).notNull(),
  // Percentage chance 0-100
  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow()
});
var DEFAULT_PRICES = [
  { item_type: "baby_chicken", price: 90 },
  { item_type: "regular_chicken", price: 150 },
  { item_type: "golden_chicken", price: 400 },
  { item_type: "water_bucket", price: 0.5 },
  { item_type: "wheat_bag", price: 0.5 },
  { item_type: "egg", price: 0.1 }
];
var initializeDefaultsQuery = `
  INSERT INTO prices (item_type, price)
  VALUES ${DEFAULT_PRICES.map((p) => `('${p.item_type}', ${p.price})`).join(", ")}
  ON CONFLICT (item_type) DO NOTHING;
`;
var insertUserSchema = createInsertSchema(users).pick({
  username: true,
  password: true,
  referredBy: true,
  telegramId: true
}).extend({
  username: z.string().min(3, "Username must be at least 3 characters"),
  password: z.string().min(6, "Password must be at least 6 characters"),
  referredBy: z.string().nullish(),
  telegramId: z.string().nullish()
}).partial({
  referredBy: true,
  telegramId: true
});
var insertChickenSchema = createInsertSchema(chickens);
var insertResourceSchema = createInsertSchema(resources);
var insertTransactionSchema = createInsertSchema(transactions).extend({
  amount: z.number().min(0.01, "Amount must be greater than 0").max(1e6, "Amount cannot exceed 1,000,000"),
  type: z.enum(["recharge", "withdrawal", "purchase", "commission", "mystery_box"]),
  status: z.enum(["pending", "completed", "rejected"]),
  bankDetails: z.string().nullish()
});
var insertPriceSchema = createInsertSchema(prices);
var insertUserProfileSchema = createInsertSchema(userProfiles).omit({
  id: true,
  lastUpdated: true
});
var insertGameSettingSchema = createInsertSchema(gameSettings).omit({
  id: true,
  updatedAt: true
});
var insertMysteryBoxRewardSchema = createInsertSchema(mysteryBoxRewards).omit({
  id: true,
  createdAt: true,
  claimedAt: true
});
var insertReferralEarningSchema = createInsertSchema(referralEarnings).omit({
  id: true,
  createdAt: true
});
var insertMilestoneRewardSchema = createInsertSchema(milestoneRewards).omit({
  id: true,
  claimedAt: true,
  createdAt: true
});
var insertSalaryPaymentSchema = createInsertSchema(salaryPayments).omit({
  id: true,
  paidAt: true
});
var insertDailyRewardSchema = createInsertSchema(dailyRewards).omit({
  id: true,
  createdAt: true
});
var insertActiveBoostSchema = createInsertSchema(activeBoosts).omit({
  id: true,
  createdAt: true
});
var insertSpinHistorySchema = createInsertSchema(spinHistory).omit({
  id: true,
  createdAt: true
});
var insertSpinRewardSchema = createInsertSchema(spinRewards).omit({
  id: true,
  createdAt: true,
  updatedAt: true
});
var possibleMysteryBoxRewards = [
  { rewardType: "usdt", min: 1, max: 50 },
  { rewardType: "chicken", types: ["baby", "regular", "golden"] },
  { rewardType: "resources", types: [
    { type: "water_buckets", min: 5, max: 20 },
    { type: "wheat_bags", min: 5, max: 20 }
  ] }
];
var referralCommissionRates = {
  level1: 0.1,
  // 10% for direct referrals
  level2: 0.06,
  // 6% for second level
  level3: 0.04,
  // 4% for third level
  level4: 0.03,
  // 3% for fourth level
  level5: 0.02,
  // 2% for fifth level
  level6: 0.01
  // 1% for sixth level
};
var milestoneThresholds = [
  { threshold: 1e3, reward: 50 },
  // $1,000 total referral earnings -> $50 bonus
  { threshold: 1e4, reward: 500 },
  // $10,000 -> $500 bonus
  { threshold: 5e4, reward: 2500 },
  // $50,000 -> $2,500 bonus
  { threshold: 1e5, reward: 5e3 }
  // $100,000 -> $5,000 bonus
];
var SALARY_PER_REFERRAL = 1;
var dailyRewardsByDay = [
  { day: 1, eggs: 2, usdt: 0 },
  { day: 2, eggs: 4, usdt: 0 },
  { day: 3, eggs: 6, usdt: 0 },
  { day: 4, eggs: 8, usdt: 0 },
  { day: 5, eggs: 10, usdt: 0.5 },
  { day: 6, eggs: 15, usdt: 0.75 },
  { day: 7, eggs: 20, usdt: 1 }
  // Weekly bonus
];
var boostTypes = [
  { id: "2x_1h", name: "2x Egg Production (1 Hour)", multiplier: 2, hours: 1, price: 10 },
  { id: "1.5x_6h", name: "1.5x Egg Production (6 Hours)", multiplier: 1.5, hours: 6, price: 20 },
  { id: "1.2x_24h", name: "1.2x Egg Production (24 Hours)", multiplier: 1.2, hours: 24, price: 30 }
];
var achievementBadges = pgTable("achievement_badges", {
  id: serial("id").primaryKey(),
  code: text("code").notNull().unique(),
  // Unique identifier code for the badge
  name: text("name").notNull(),
  description: text("description").notNull(),
  category: text("category").notNull(),
  // 'investment', 'farming', 'social', 'milestone'
  iconSvg: text("icon_svg").notNull(),
  // SVG string for the badge icon
  rarity: text("rarity").notNull(),
  // 'common', 'rare', 'epic', 'legendary'
  threshold: integer("threshold").notNull(),
  // Value needed to unlock
  createdAt: timestamp("created_at").notNull().defaultNow()
});
var userAchievements = pgTable("user_achievements", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull(),
  badgeId: integer("badge_id").notNull(),
  unlockedAt: timestamp("unlocked_at").notNull().defaultNow(),
  progress: integer("progress").notNull().default(0),
  // Current progress towards threshold
  isComplete: boolean("is_complete").notNull().default(false)
});
var insertAchievementBadgeSchema = createInsertSchema(achievementBadges).omit({
  id: true,
  createdAt: true
});
var insertUserAchievementSchema = createInsertSchema(userAchievements).omit({
  id: true,
  unlockedAt: true
});
var DEFAULT_ACHIEVEMENT_BADGES = [
  // Investment category badges
  {
    code: "first_deposit",
    name: "Crypto Initiate",
    description: "Made your first USDT deposit",
    category: "investment",
    rarity: "common",
    threshold: 1,
    iconSvg: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><circle cx="32" cy="32" r="30" fill="#26a17b"/><path fill="#fff" d="M36.5,17.2h-9v18.6h9V17.2z"/><path fill="#fff" d="M32,11.6c-8.1,0-14.6,6.6-14.6,14.6s6.6,14.6,14.6,14.6s14.6-6.6,14.6-14.6S40.1,11.6,32,11.6z M32,37.1c-6,0-10.9-4.9-10.9-10.9c0-6,4.9-10.9,10.9-10.9c6,0,10.9,4.9,10.9,10.9C42.9,32.2,38,37.1,32,37.1z"/><path fill="#fff" d="M42.1,39.6c-0.5,0-0.9,0.4-0.9,0.9v2.2c0,0.5,0.4,0.9,0.9,0.9s0.9-0.4,0.9-0.9v-2.2C43,40,42.6,39.6,42.1,39.6z"/></svg>'
  },
  {
    code: "hodler",
    name: "HODL Champion",
    description: "Held a balance of 100+ USDT",
    category: "investment",
    rarity: "rare",
    threshold: 100,
    iconSvg: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><circle cx="32" cy="32" r="30" fill="#f9aa4b"/><path fill="#fff" d="M32,12.4l-8.9,15.3L32,33.1l8.9-5.4L32,12.4z"/><path fill="#fff" d="M32,35.2L23.1,29.8L32,51.6l8.9-21.8L32,35.2z"/><path fill="#fff" d="M32,33.1l8.9-5.4l-8.9-5.3V33.1z"/><path fill="#fff" d="M23.1,22.4l8.9,5.3v-10.7L23.1,22.4z"/></svg>'
  },
  {
    code: "crypto_whale",
    name: "Crypto Whale",
    description: "Achieved a balance of 1000+ USDT",
    category: "investment",
    rarity: "epic",
    threshold: 1e3,
    iconSvg: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><circle cx="32" cy="32" r="30" fill="#627eea"/><path fill="#fff" d="M32,13v14l11.9,5.3L32,13z"/><path fill="#fff" fill-opacity="0.8" d="M32,13l-11.9,19.3L32,27V13z"/><path fill="#fff" d="M32,41.7v9.3l11.9-16.5L32,41.7z"/><path fill="#fff" fill-opacity="0.8" d="M32,51v-9.3l-11.9-7.2L32,51z"/><path fill="#fff" d="M32,39.3l11.9-7.2L32,27V39.3z"/><path fill="#fff" fill-opacity="0.8" d="M20.1,32.1L32,39.3V27L20.1,32.1z"/></svg>'
  },
  // Farming category badges
  {
    code: "egg_collector",
    name: "Egg Collector",
    description: "Collected 100 eggs from your chickens",
    category: "farming",
    rarity: "common",
    threshold: 100,
    iconSvg: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><circle cx="32" cy="32" r="30" fill="#f0b90b"/><ellipse cx="32" cy="35" rx="14" ry="16" fill="#fff"/><path fill="#f0b90b" d="M32,20c-7.7,0-14,6.7-14,15s6.3,15,14,15s14-6.7,14-15S39.7,20,32,20z M32,45c-5.5,0-10-4.5-10-10s4.5-10,10-10s10,4.5,10,10S37.5,45,32,45z"/><circle cx="32" cy="35" r="6" fill="#f0b90b"/></svg>'
  },
  {
    code: "chicken_master",
    name: "Chicken Master",
    description: "Owned 10 or more chickens simultaneously",
    category: "farming",
    rarity: "rare",
    threshold: 10,
    iconSvg: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><circle cx="32" cy="32" r="30" fill="#ff9900"/><path fill="#fff" d="M42,27c0,5.5-4.5,10-10,10s-10-4.5-10-10s4.5-10,10-10S42,21.5,42,27z"/><path fill="#fff" d="M24,35c0,0-4,4-4,8s2,6,2,6h20c0,0,2-2,2-6s-4-8-4-8"/><circle cx="28" cy="26" r="2" fill="#ff9900"/><circle cx="36" cy="26" r="2" fill="#ff9900"/><path fill="#ff9900" d="M29,30h6c0,0,0,2-3,2S29,30,29,30z"/></svg>'
  },
  {
    code: "golden_farm",
    name: "Golden Farm",
    description: "Owned 5 golden chickens simultaneously",
    category: "farming",
    rarity: "legendary",
    threshold: 5,
    iconSvg: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><circle cx="32" cy="32" r="30" fill="#f7931a"/><path fill="#fff" d="M42,32c0,5.5-4.5,10-10,10s-10-4.5-10-10s4.5-10,10-10S42,26.5,42,32z"/><path fill="#f7931a" d="M39,37c0,0-4,10-16,10c0,0,10-4,10-10H39z"/><path fill="#f7931a" d="M25,37c0,0,4,10,16,10c0,0-10-4-10-10H25z"/><path fill="#f7931a" d="M37,25c0,0-3-5-5-5s-5,5-5,5s2-3,5-3S37,25,37,25z"/><path fill="#fff" d="M32,27l-4,5h8L32,27z"/></svg>'
  },
  // Social category badges
  {
    code: "referral_starter",
    name: "Blockchain Ambassador",
    description: "Invited your first referral",
    category: "social",
    rarity: "common",
    threshold: 1,
    iconSvg: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><circle cx="32" cy="32" r="30" fill="#3c3c3d"/><circle cx="24" cy="26" r="6" fill="#fff"/><circle cx="40" cy="26" r="6" fill="#fff"/><circle cx="32" cy="42" r="6" fill="#fff"/><path stroke="#fff" stroke-width="2" d="M24,26L32,42L40,26" fill="none"/><path stroke="#fff" stroke-width="2" d="M24,26L40,26" fill="none"/></svg>'
  },
  {
    code: "network_builder",
    name: "Network Builder",
    description: "Built a referral network of 10+ users",
    category: "social",
    rarity: "epic",
    threshold: 10,
    iconSvg: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><circle cx="32" cy="32" r="30" fill="#8247e5"/><circle cx="32" cy="22" r="5" fill="#fff"/><circle cx="22" cy="38" r="5" fill="#fff"/><circle cx="42" cy="38" r="5" fill="#fff"/><path stroke="#fff" stroke-width="2" d="M32,27L22,33" fill="none"/><path stroke="#fff" stroke-width="2" d="M32,27L42,33" fill="none"/><path stroke="#fff" stroke-width="2" d="M22,43L42,43" fill="none"/></svg>'
  },
  // Milestone category badges
  {
    code: "daily_streak",
    name: "Blockchain Miner",
    description: "Maintained a login streak of 7 days",
    category: "milestone",
    rarity: "common",
    threshold: 7,
    iconSvg: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><circle cx="32" cy="32" r="30" fill="#4285f4"/><rect x="22" y="22" width="20" height="20" rx="2" fill="#fff"/><path fill="#4285f4" d="M36,28h-8c-1.1,0-2,0.9-2,2v4c0,1.1,0.9,2,2,2h8c1.1,0,2-0.9,2-2v-4C38,28.9,37.1,28,36,28z M35,33h-6v-2h6V33z"/><path fill="#4285f4" d="M30,22v-4h4v4H30z"/><path fill="#4285f4" d="M30,46v-4h4v4H30z"/><path fill="#4285f4" d="M46,30h-4v4h4V30z"/><path fill="#4285f4" d="M22,30h-4v4h4V30z"/></svg>'
  },
  {
    code: "super_spinner",
    name: "Super Spinner",
    description: "Spun the super jackpot wheel 10 times",
    category: "milestone",
    rarity: "rare",
    threshold: 10,
    iconSvg: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><circle cx="32" cy="32" r="30" fill="#2a71d0"/><circle cx="32" cy="32" r="20" fill="#fff"/><path fill="#2a71d0" d="M32,12v40c11,0,20-9,20-20S43,12,32,12z"/><path fill="#fff" d="M32,22v20c-5.5,0-10-4.5-10-10S26.5,22,32,22z"/><path fill="#2a71d0" d="M32,22v20c5.5,0,10-4.5,10-10S37.5,22,32,22z"/><circle cx="27" cy="27" r="3" fill="#fff"/><circle cx="37" cy="37" r="3" fill="#fff"/></svg>'
  },
  {
    code: "mystery_master",
    name: "Mystery Box Master",
    description: "Opened 25 mystery boxes",
    category: "milestone",
    rarity: "epic",
    threshold: 25,
    iconSvg: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><circle cx="32" cy="32" r="30" fill="#eb8c39"/><rect x="18" y="24" width="28" height="20" rx="2" fill="#fff"/><path fill="#eb8c39" d="M32,20l-10,4h20L32,20z"/><path fill="#eb8c39" d="M24,30h16v4H24V30z"/><circle cx="32" cy="38" r="2" fill="#eb8c39"/></svg>'
  }
];

// server/db.ts
var { Pool } = pkg;
if (!process.env.DATABASE_URL) {
  throw new Error(
    "DATABASE_URL must be set. Did you forget to provision a database?"
  );
}
var pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: {
    rejectUnauthorized: false
  }
});
var db = drizzle(pool, { schema: schema_exports });

// server/storage.ts
import session from "express-session";
import createMemoryStore from "memorystore";
import pgSessionStore from "connect-pg-simple";
import { randomBytes as randomBytes2 } from "crypto";

// server/auth-utils.ts
import { scrypt, randomBytes, timingSafeEqual } from "crypto";
import { promisify } from "util";
var scryptAsync = promisify(scrypt);
async function hashPassword(password) {
  const salt = randomBytes(16).toString("hex");
  const buf = await scryptAsync(password, salt, 64);
  return `${buf.toString("hex")}.${salt}`;
}
async function comparePasswords(supplied, stored) {
  try {
    const [hashed, salt] = stored.split(".");
    if (!hashed || !salt) {
      console.log("[Auth] Invalid stored password format");
      return false;
    }
    const hashedBuf = Buffer.from(hashed, "hex");
    const suppliedBuf = await scryptAsync(supplied, salt, 64);
    return timingSafeEqual(hashedBuf, suppliedBuf);
  } catch (error) {
    console.error("[Auth] Password comparison error:", error);
    return false;
  }
}

// server/storage.ts
var MemoryStore = createMemoryStore(session);
var PGStore = pgSessionStore(session);
var DatabaseStorage = class {
  sessionStore;
  defaultPaymentAddress = "TRX8nHHo2Jd7H9ZwKhh6h8h";
  defaultWithdrawalTax = 5;
  constructor() {
    this.sessionStore = new PGStore({
      pool,
      // Use the existing PostgreSQL connection pool
      tableName: "session",
      // Name of the session table
      createTableIfMissing: true
      // Automatically create the session table if it doesn't exist
    });
    this.initializeDefaults();
  }
  async initializeDefaults() {
    try {
      await this.initializePrices();
      await this.initializeAdminUser();
      await this.initializeGameSettings();
      await this.initializeAchievementBadges();
      await this.initializeSpinRewards();
    } catch (error) {
      console.error("Error in initializeDefaults:", error);
      throw error;
    }
  }
  async initializeGameSettings() {
    try {
      const [withdrawalTaxSetting] = await db.select().from(gameSettings).where(eq(gameSettings.settingKey, "withdrawal_tax"));
      if (!withdrawalTaxSetting) {
        await db.insert(gameSettings).values({
          settingKey: "withdrawal_tax",
          settingValue: this.defaultWithdrawalTax.toString()
        });
      }
      const [paymentAddressSetting] = await db.select().from(gameSettings).where(eq(gameSettings.settingKey, "payment_address"));
      if (!paymentAddressSetting) {
        await db.insert(gameSettings).values({
          settingKey: "payment_address",
          settingValue: this.defaultPaymentAddress
        });
      }
    } catch (error) {
      console.error("Error initializing game settings:", error);
      throw error;
    }
  }
  async initializeAdminUser() {
    try {
      console.log("[Storage] Checking for admin user existence...");
      const adminExists = await this.getUserByUsername("adminraja");
      if (!adminExists) {
        console.log("[Storage] Admin user not found, creating new admin account...");
        const hashedPassword = await hashPassword("admin8751");
        await db.insert(users).values({
          username: "adminraja",
          password: hashedPassword,
          usdtBalance: "0",
          referralCode: "ADMIN",
          isAdmin: true
        });
        const [admin] = await db.select().from(users).where(eq(users.username, "adminraja"));
        console.log("[Storage] Created admin user with ID:", admin.id);
        await db.insert(resources).values({
          userId: admin.id,
          waterBuckets: 0,
          wheatBags: 0,
          eggs: 0
        });
        console.log("[Storage] Admin user created successfully with resources initialized");
      } else {
        console.log("[Storage] Admin user already exists with ID:", adminExists.id);
      }
    } catch (error) {
      console.error("[Storage] Error initializing admin user:", error);
      throw error;
    }
  }
  async initializePrices() {
    try {
      const defaultPrices = [
        { itemType: "baby_chicken", price: "90" },
        { itemType: "regular_chicken", price: "150" },
        { itemType: "golden_chicken", price: "400" },
        { itemType: "water_bucket", price: "0.5" },
        { itemType: "wheat_bag", price: "0.5" },
        { itemType: "egg", price: "0.1" },
        { itemType: "mystery_box", price: "50" }
      ];
      for (const price of defaultPrices) {
        const [existing] = await db.select().from(prices).where(eq(prices.itemType, price.itemType));
        if (!existing) {
          await db.insert(prices).values(price);
        }
      }
      console.log("[Storage] Prices initialized successfully");
    } catch (error) {
      console.error("[Storage] Error initializing prices:", error);
      throw error;
    }
  }
  async getUser(id) {
    const [user] = await db.select().from(users).where(eq(users.id, id));
    return user;
  }
  // New method to update referral counts for users
  async updateReferralCounts() {
    try {
      const allUsers = await db.select().from(users);
      for (const user of allUsers) {
        const referrals = await db.select().from(users).where(eq(users.referredBy, user.referralCode));
        await db.update(users).set({ referralCount: referrals.length }).where(eq(users.id, user.id));
        console.log(`Updated referral count for user ${user.id} to ${referrals.length}`);
      }
      console.log("Successfully updated referral counts for all users");
    } catch (error) {
      console.error("Error updating referral counts:", error);
      throw error;
    }
  }
  async getUserByUsername(username) {
    const [user] = await db.select().from(users).where(eq(users.username, username));
    return user;
  }
  async getUserByReferralCode(referralCode) {
    const [user] = await db.select().from(users).where(eq(users.referralCode, referralCode));
    return user;
  }
  async createUser(insertUser) {
    try {
      const referralCode = randomBytes2(4).toString("hex");
      const [user] = await db.insert(users).values({
        ...insertUser,
        usdtBalance: "0",
        referralCode,
        isAdmin: false
      }).returning();
      await db.insert(resources).values({
        userId: user.id,
        waterBuckets: 0,
        wheatBags: 0,
        eggs: 0,
        mysteryBoxes: 0
      });
      if (insertUser.referredBy) {
        try {
          const referrer = await this.getUserByReferralCode(insertUser.referredBy);
          if (referrer) {
            await db.update(users).set({
              referralCount: sql`${users.referralCount} + 1`
            }).where(eq(users.id, referrer.id));
            console.log(`Updated referral count for user ${referrer.id}`);
          }
        } catch (referralError) {
          console.error("Error updating referrer's referral count:", referralError);
        }
      }
      return user;
    } catch (error) {
      console.error("Error creating user:", error);
      throw error;
    }
  }
  async updateUserBalance(userId, amount) {
    try {
      const [user] = await db.select().from(users).where(eq(users.id, userId));
      if (!user) throw new Error("User not found");
      const newBalance = parseFloat(user.usdtBalance) + amount;
      if (newBalance < 0) throw new Error("Insufficient USDT balance");
      await db.update(users).set({ usdtBalance: newBalance.toFixed(2) }).where(eq(users.id, userId));
    } catch (error) {
      console.error("Error updating user balance:", error);
      throw error;
    }
  }
  async getUserReferrals(userId) {
    try {
      const user = await this.getUser(userId);
      if (!user) throw new Error("User not found");
      return db.select().from(users).where(eq(users.referredBy, user.referralCode));
    } catch (error) {
      console.error("Error getting user referrals:", error);
      throw error;
    }
  }
  async updateUserReferralEarnings(userId, amount) {
    try {
      const [user] = await db.select().from(users).where(eq(users.id, userId));
      if (!user) throw new Error("User not found");
      const newEarnings = parseFloat(user.totalReferralEarnings || "0") + amount;
      await db.update(users).set({ totalReferralEarnings: newEarnings.toFixed(2) }).where(eq(users.id, userId));
      await this.checkAndCreateMilestoneRewards(userId, newEarnings);
    } catch (error) {
      console.error("Error updating user referral earnings:", error);
      throw error;
    }
  }
  async checkAndCreateMilestoneRewards(userId, totalEarnings) {
    try {
      for (const milestone of milestoneThresholds) {
        if (totalEarnings >= milestone.threshold) {
          const existingMilestones = await this.getMilestoneRewardsByUserId(userId);
          const alreadyAwarded = existingMilestones.some(
            (m) => parseFloat(m.milestone.toString()) === milestone.threshold
          );
          if (!alreadyAwarded) {
            await this.createMilestoneReward({
              userId,
              milestone: milestone.threshold.toString(),
              reward: milestone.reward.toString(),
              claimed: false
            });
          }
        }
      }
    } catch (error) {
      console.error("Error checking and creating milestone rewards:", error);
    }
  }
  async updateUserTeamEarnings(userId, amount) {
    try {
      const [user] = await db.select().from(users).where(eq(users.id, userId));
      if (!user) throw new Error("User not found");
      const newEarnings = parseFloat(user.totalTeamEarnings || "0") + amount;
      await db.update(users).set({ totalTeamEarnings: newEarnings.toFixed(2) }).where(eq(users.id, userId));
      await this.checkAndProcessMonthlySalary(userId, newEarnings);
    } catch (error) {
      console.error("Error updating user team earnings:", error);
      throw error;
    }
  }
  async checkAndProcessMonthlySalary(userId, totalTeamEarnings) {
    try {
      const user = await this.getUser(userId);
      if (!user) return;
      const directReferrals = await this.getUserReferrals(userId);
      let referralsWithDeposits = 0;
      for (const referral of directReferrals) {
        const referralTransactions = await this.getTransactionsByUserId(referral.id);
        const hasDeposit = referralTransactions.some(
          (transaction) => transaction.type === "recharge" && transaction.status === "completed"
        );
        if (hasDeposit) {
          referralsWithDeposits++;
        }
      }
      const eligibleSalary = referralsWithDeposits * SALARY_PER_REFERRAL;
      if (eligibleSalary > 0) {
        const currentDate = /* @__PURE__ */ new Date();
        const currentMonth = `${currentDate.getFullYear()}-${String(currentDate.getMonth() + 1).padStart(2, "0")}`;
        const salaryPayments2 = await this.getSalaryPaymentsByUserId(userId);
        const alreadyPaid = salaryPayments2.some((payment) => payment.period === currentMonth);
        if (!alreadyPaid) {
          const lastPaidAt = user.lastSalaryPaidAt;
          const shouldPay = !lastPaidAt || currentDate.getTime() - new Date(lastPaidAt).getTime() >= 28 * 24 * 60 * 60 * 1e3;
          if (shouldPay) {
            await this.createSalaryPayment({
              userId,
              amount: eligibleSalary.toString(),
              period: currentMonth
            });
            await this.updateUserBalance(userId, eligibleSalary);
            await this.updateLastSalaryPaid(userId, currentDate);
          }
        }
      }
    } catch (error) {
      console.error("Error checking and processing monthly salary:", error);
    }
  }
  async updateUserStreak(userId, streak) {
    try {
      await db.update(users).set({ currentStreak: streak }).where(eq(users.id, userId));
    } catch (error) {
      console.error("Error updating user streak:", error);
      throw error;
    }
  }
  async updateLastDailyReward(userId, date2) {
    try {
      await db.update(users).set({ lastDailyRewardAt: date2.toISOString().split("T")[0] }).where(eq(users.id, userId));
    } catch (error) {
      console.error("Error updating last daily reward:", error);
      throw error;
    }
  }
  async updateLastSalaryPaid(userId, date2) {
    try {
      await db.update(users).set({ lastSalaryPaidAt: date2 }).where(eq(users.id, userId));
    } catch (error) {
      console.error("Error updating last salary paid date:", error);
      throw error;
    }
  }
  async getChickensByUserId(userId) {
    await this.checkAndUpdateChickenStatus(userId);
    return db.select().from(chickens).where(eq(chickens.userId, userId));
  }
  async createChicken(userId, type) {
    const [chicken] = await db.insert(chickens).values({
      userId,
      type,
      status: "alive",
      createdAt: /* @__PURE__ */ new Date()
    }).returning();
    return chicken;
  }
  // Check if any baby chickens have reached the end of their lifespan
  async checkAndUpdateChickenStatus(userId) {
    try {
      const babyChickens = await db.select().from(chickens).where(
        and(
          eq(chickens.userId, userId),
          eq(chickens.type, "baby"),
          eq(chickens.status, "alive")
        )
      );
      const now = /* @__PURE__ */ new Date();
      for (const chicken of babyChickens) {
        if (chicken.createdAt) {
          const createdAt = new Date(chicken.createdAt);
          const chickAge = now.getTime() - createdAt.getTime();
          if (chickAge > CHICKEN_LIFESPAN.baby) {
            await this.markChickenAsDead(chicken.id);
          }
        }
      }
    } catch (error) {
      console.error("Error checking chicken status:", error);
    }
  }
  // Mark a chicken as dead
  async markChickenAsDead(chickenId) {
    try {
      await db.update(chickens).set({
        status: "dead",
        deathDate: /* @__PURE__ */ new Date()
      }).where(eq(chickens.id, chickenId));
    } catch (error) {
      console.error("Error marking chicken as dead:", error);
    }
  }
  async updateChickenHatchTime(chickenId) {
    await db.update(chickens).set({ lastHatchTime: /* @__PURE__ */ new Date() }).where(eq(chickens.id, chickenId));
  }
  async deleteChicken(chickenId) {
    await db.delete(chickens).where(eq(chickens.id, chickenId));
  }
  async getChickenCountsByType() {
    const result = await db.select({
      type: chickens.type,
      count: sql`COUNT(*)`
    }).from(chickens).groupBy(chickens.type);
    return result.map((item) => {
      return {
        type: item.type,
        count: parseInt(String(item.count), 10)
      };
    });
  }
  async getResourcesByUserId(userId) {
    try {
      const [resource] = await db.select().from(resources).where(eq(resources.userId, userId));
      if (!resource) {
        const [newResource] = await db.insert(resources).values({
          userId,
          waterBuckets: 0,
          wheatBags: 0,
          eggs: 0,
          mysteryBoxes: 0
        }).returning();
        return newResource;
      }
      return resource;
    } catch (error) {
      console.error("Error fetching or creating resources:", error);
      throw new Error("Failed to create resources");
    }
  }
  async updateResources(userId, updates) {
    const [updated] = await db.update(resources).set(updates).where(eq(resources.userId, userId)).returning();
    return updated;
  }
  async createTransaction(userId, type, amount, transactionId, referralCommission, bankDetails) {
    const [transaction] = await db.insert(transactions).values({
      userId,
      type,
      amount: amount.toString(),
      status: "pending",
      transactionId: transactionId || randomBytes2(16).toString("hex"),
      referralCommission: referralCommission?.toString(),
      bankDetails
    }).returning();
    return transaction;
  }
  async getTransactionsByUserId(userId) {
    return db.select().from(transactions).where(eq(transactions.userId, userId)).orderBy(desc(transactions.createdAt));
  }
  async updateTransactionStatus(transactionId, status) {
    await db.update(transactions).set({ status }).where(eq(transactions.transactionId, transactionId));
  }
  async getPrices() {
    return db.select().from(prices);
  }
  async updatePrice(itemType, price) {
    await db.update(prices).set({ price: price.toFixed(2) }).where(eq(prices.itemType, itemType));
  }
  async getTransactions() {
    return db.select().from(transactions).orderBy(desc(transactions.createdAt));
  }
  async getTransactionByTransactionId(transactionId) {
    const [transaction] = await db.select().from(transactions).where(eq(transactions.transactionId, transactionId));
    return transaction;
  }
  async updatePaymentAddress(address) {
    try {
      await db.update(gameSettings).set({ settingValue: address }).where(eq(gameSettings.settingKey, "payment_address"));
    } catch (error) {
      console.error("Error updating payment address:", error);
      throw error;
    }
  }
  async updateWithdrawalTax(percentage) {
    if (percentage < 0 || percentage > 100) {
      throw new Error("Withdrawal tax percentage must be between 0 and 100");
    }
    try {
      await db.update(gameSettings).set({ settingValue: percentage.toString() }).where(eq(gameSettings.settingKey, "withdrawal_tax"));
    } catch (error) {
      console.error("Error updating withdrawal tax:", error);
      throw error;
    }
  }
  async getSettings() {
    try {
      const settings = await db.select().from(gameSettings);
      const settingsObject = {};
      for (const setting of settings) {
        settingsObject[setting.settingKey] = setting.settingValue;
      }
      return {
        withdrawalTax: parseFloat(settingsObject.withdrawal_tax || this.defaultWithdrawalTax.toString()),
        paymentAddress: settingsObject.payment_address || this.defaultPaymentAddress
      };
    } catch (error) {
      console.error("Error getting game settings:", error);
      return {
        withdrawalTax: this.defaultWithdrawalTax,
        paymentAddress: this.defaultPaymentAddress
      };
    }
  }
  async getUserProfile(userId) {
    const [profile] = await db.select().from(userProfiles).where(eq(userProfiles.userId, userId));
    return profile;
  }
  async createUserProfile(profile) {
    const [newProfile] = await db.insert(userProfiles).values({
      ...profile,
      avatarColor: profile.avatarColor || "#6366F1",
      avatarStyle: profile.avatarStyle || "default",
      farmBackground: profile.farmBackground || "default"
    }).returning();
    return newProfile;
  }
  async updateUserProfile(userId, updates) {
    const [currentProfile] = await db.select().from(userProfiles).where(eq(userProfiles.userId, userId));
    if (!currentProfile) {
      return this.createUserProfile({
        userId,
        ...updates
      });
    }
    const [updatedProfile] = await db.update(userProfiles).set({
      ...updates,
      lastUpdated: /* @__PURE__ */ new Date()
    }).where(eq(userProfiles.userId, userId)).returning();
    return updatedProfile;
  }
  async updateTutorialProgress(userId, step) {
    try {
      const [currentProfile] = await db.select().from(userProfiles).where(eq(userProfiles.userId, userId));
      if (!currentProfile) {
        return this.createUserProfile({
          userId,
          tutorialStep: step
        });
      }
      const [updatedProfile] = await db.update(userProfiles).set({
        tutorialStep: step,
        lastUpdated: /* @__PURE__ */ new Date()
      }).where(eq(userProfiles.userId, userId)).returning();
      return updatedProfile;
    } catch (error) {
      console.error("Error updating tutorial progress:", error);
      throw error;
    }
  }
  async completeTutorial(userId) {
    try {
      const [currentProfile] = await db.select().from(userProfiles).where(eq(userProfiles.userId, userId));
      if (!currentProfile) {
        return this.createUserProfile({
          userId,
          tutorialCompleted: true
        });
      }
      const [updatedProfile] = await db.update(userProfiles).set({
        tutorialCompleted: true,
        lastUpdated: /* @__PURE__ */ new Date()
      }).where(eq(userProfiles.userId, userId)).returning();
      return updatedProfile;
    } catch (error) {
      console.error("Error completing tutorial:", error);
      throw error;
    }
  }
  async disableTutorial(userId) {
    try {
      const [currentProfile] = await db.select().from(userProfiles).where(eq(userProfiles.userId, userId));
      if (!currentProfile) {
        return this.createUserProfile({
          userId,
          tutorialDisabled: true
        });
      }
      const [updatedProfile] = await db.update(userProfiles).set({
        tutorialDisabled: true,
        lastUpdated: /* @__PURE__ */ new Date()
      }).where(eq(userProfiles.userId, userId)).returning();
      return updatedProfile;
    } catch (error) {
      console.error("Error disabling tutorial:", error);
      throw error;
    }
  }
  // Mystery Box operations
  async purchaseMysteryBox(userId, boxType = "basic") {
    try {
      console.log(`[MysteryBox] Purchasing box type ${boxType} for user ${userId}`);
      const boxConfig = mysteryBoxTypes2[boxType];
      if (!boxConfig) {
        throw new Error("Invalid mystery box type");
      }
      const user = await this.getUser(userId);
      if (!user) throw new Error("User not found");
      const userBalance = parseFloat(user.usdtBalance);
      if (userBalance < boxConfig.price) {
        throw new Error("Insufficient USDT balance");
      }
      await this.updateUserBalance(userId, -boxConfig.price);
      const resource = await this.getResourcesByUserId(userId);
      await this.updateResources(userId, {
        ...resource,
        mysteryBoxes: (resource.mysteryBoxes || 0) + 1
      });
      await this.createTransaction(
        userId,
        "mystery_box",
        boxConfig.price,
        void 0,
        void 0,
        JSON.stringify({ action: "purchase", boxType })
      );
      console.log(`[MysteryBox] Successfully purchased box for user ${userId}`);
    } catch (error) {
      console.error("[MysteryBox] Error purchasing box:", error);
      throw error;
    }
  }
  async openMysteryBox(userId, boxType = "basic") {
    try {
      console.log(`[MysteryBox] Opening box for user ${userId}, type: ${boxType}`);
      const reward = await this.checkAndProcessMysteryBoxOpen(userId, boxType);
      console.log(`[MysteryBox] Successfully opened box with ID ${reward.id}:`, reward);
      return reward;
    } catch (error) {
      console.error("[MysteryBox] Error opening mystery box:", error);
      return null;
    }
  }
  async checkAndProcessMysteryBoxOpen(userId, boxType) {
    try {
      const resource = await this.getResourcesByUserId(userId);
      console.log(`[MysteryBox] User resources:`, resource);
      if (!resource.mysteryBoxes || resource.mysteryBoxes <= 0) {
        throw new Error("No mystery boxes available");
      }
      const boxConfig = mysteryBoxTypes2[boxType];
      if (!boxConfig) {
        throw new Error("Invalid box type");
      }
      const reward = this.getRandomReward(boxType);
      const rarity = this.determineRarity(boxType);
      console.log(`[MysteryBox] Generated reward:`, reward, `rarity:`, rarity);
      const mysteryBoxReward = await this.createMysteryBoxReward({
        userId,
        boxType,
        rewardType: reward.rewardType,
        rewardDetails: reward,
        rarity,
        opened: false
      });
      console.log(`[MysteryBox] Created reward with ID ${mysteryBoxReward.id}:`, mysteryBoxReward);
      await this.updateResources(userId, {
        ...resource,
        mysteryBoxes: resource.mysteryBoxes - 1
      });
      return mysteryBoxReward;
    } catch (error) {
      console.error("[MysteryBox] Error processing mystery box open:", error);
      throw error;
    }
  }
  getRandomReward(boxType) {
    try {
      const boxConfig = mysteryBoxTypes2[boxType];
      if (!boxConfig) throw new Error("Invalid box type");
      const rand = Math.random();
      let threshold = 0;
      if (boxConfig.rewards.usdt?.ranges) {
        for (const range of boxConfig.rewards.usdt.ranges) {
          threshold += range.chance;
          if (rand < threshold) {
            return {
              rewardType: "usdt",
              amount: range.amount
            };
          }
        }
      }
      if (boxConfig.rewards.chicken) {
        threshold += boxConfig.rewards.chicken.chance;
        if (rand < threshold) {
          const chickenTypes = boxConfig.rewards.chicken.types;
          const randomChickenType = chickenTypes[Math.floor(Math.random() * chickenTypes.length)];
          return {
            rewardType: "chicken",
            chickenType: randomChickenType
          };
        }
      }
      if (boxConfig.rewards.eggs?.ranges) {
        for (const range of boxConfig.rewards.eggs.ranges) {
          threshold += range.chance;
          if (rand < threshold) {
            const eggAmount = Math.floor(Math.random() * (range.max - range.min + 1)) + range.min;
            return {
              rewardType: "eggs",
              minEggs: eggAmount,
              maxEggs: eggAmount
            };
          }
        }
      }
      if (boxConfig.rewards.resources) {
        const resourceType = Math.random() < 0.5 ? "wheat_bags" : "water_buckets";
        const resourceKey = resourceType === "wheat_bags" ? "wheat" : "water";
        if (boxConfig.rewards.resources[resourceKey] && boxConfig.rewards.resources[resourceKey]?.ranges) {
          const ranges = boxConfig.rewards.resources[resourceKey]?.ranges || [];
          if (ranges.length > 0) {
            const range = ranges[0];
            const amount = Math.floor(Math.random() * (range.max - range.min + 1)) + range.min;
            return {
              rewardType: "resources",
              resourceType,
              resourceAmount: amount
            };
          }
        }
      }
      return {
        rewardType: "eggs",
        minEggs: 1,
        maxEggs: 5
      };
    } catch (error) {
      console.error("[MysteryBox] Error generating random reward:", error);
      return {
        rewardType: "eggs",
        minEggs: 1,
        maxEggs: 5
      };
    }
  }
  determineRarity(boxType) {
    try {
      const boxConfig = mysteryBoxTypes2[boxType];
      if (!boxConfig) {
        throw new Error("Invalid box type");
      }
      const rarityDistribution = {
        common: 0.6,
        rare: 0.3,
        epic: 0.09,
        legendary: 0.01
      };
      const rand = Math.random();
      let threshold = 0;
      for (const [rarity, chance] of Object.entries(rarityDistribution)) {
        threshold += chance;
        if (rand < threshold) {
          return rarity;
        }
      }
      return "common";
    } catch (error) {
      console.error("[MysteryBox] Error determining rarity:", error);
      return "common";
    }
  }
  async claimMysteryBoxReward(rewardId) {
    try {
      if (typeof rewardId !== "number" || rewardId <= 0) {
        console.error(`[MysteryBox] Invalid reward ID: ${rewardId}`);
        throw new Error("Invalid reward ID");
      }
      console.log(`[MysteryBox] Attempting to claim reward ${rewardId}`);
      const [reward] = await db.select().from(mysteryBoxRewards).where(eq(mysteryBoxRewards.id, rewardId));
      if (!reward) {
        console.error(`[MysteryBox] Reward not found for ID: ${rewardId}`);
        throw new Error("Reward not found");
      }
      if (reward.opened) {
        console.error(`[MysteryBox] Reward ${rewardId} already claimed`);
        throw new Error("Reward already claimed");
      }
      const rewardData = reward.rewardDetails;
      console.log(`[MysteryBox] Processing reward:`, rewardData);
      switch (rewardData.rewardType) {
        case "usdt":
          if ("amount" in rewardData && rewardData.amount) {
            await this.updateUserBalance(reward.userId, rewardData.amount);
          }
          break;
        case "chicken":
          if ("chickenType" in rewardData && rewardData.chickenType) {
            await this.createChicken(reward.userId, rewardData.chickenType);
          }
          break;
        case "eggs":
          if ("minEggs" in rewardData && rewardData.minEggs) {
            const userResources = await this.getResourcesByUserId(reward.userId);
            await this.updateResources(reward.userId, {
              ...userResources,
              eggs: userResources.eggs + rewardData.minEggs
            });
          }
          break;
        case "resources":
          if ("resourceType" in rewardData && "resourceAmount" in rewardData && rewardData.resourceAmount) {
            const userRes = await this.getResourcesByUserId(reward.userId);
            const resourceMapping = {
              "wheat_bags": "wheatBags",
              "water_buckets": "waterBuckets"
            };
            if (rewardData.resourceType === "wheat_bags" || rewardData.resourceType === "water_buckets") {
              const propertyName = resourceMapping[rewardData.resourceType];
              await this.updateResources(reward.userId, {
                ...userRes,
                [propertyName]: userRes[propertyName] + rewardData.resourceAmount
              });
            }
          }
          break;
        default:
          console.error(`[MysteryBox]Invalid reward type: ${rewardData.rewardType}`);
          throw new Error(`Invalid reward type: ${rewardData.rewardType}`);
      }
      const [updatedReward] = await db.update(mysteryBoxRewards).set({
        opened: true,
        claimedAt: /* @__PURE__ */ new Date()
      }).where(eq(mysteryBoxRewards.id, rewardId)).returning();
      console.log(`[MysteryBox] Successfully claimed reward:`, updatedReward);
      return updatedReward;
    } catch (error) {
      console.error("[MysteryBox] Error claiming reward:", error);
      throw error;
    }
  }
  async getMysteryBoxRewardsByUserId(userId) {
    try {
      console.log(`[MysteryBox] Fetching rewards for user ${userId}`);
      const rewards = await db.select().from(mysteryBoxRewards).where(eq(mysteryBoxRewards.userId, userId)).orderBy(desc(mysteryBoxRewards.createdAt));
      console.log(`[MysteryBox] Retrieved rewards for user ${userId}:`, rewards.length);
      return rewards;
    } catch (error) {
      console.error("Error getting mystery box rewards:", error);
      throw error;
    }
  }
  async createMysteryBoxReward(reward) {
    try {
      const [newReward] = await db.insert(mysteryBoxRewards).values(reward).returning();
      return newReward;
    } catch (error) {
      console.error("Error creating mystery box reward:", error);
      throw error;
    }
  }
  async createReferralEarning(earning) {
    try {
      const [newEarning] = await db.insert(referralEarnings).values(earning).returning();
      return newEarning;
    } catch (error) {
      console.error("Error creating referral earning:", error);
      throw error;
    }
  }
  async getReferralEarningsByUserId(userId) {
    try {
      return db.select().from(referralEarnings).where(eq(referralEarnings.userId, userId)).orderBy(desc(referralEarnings.createdAt));
    } catch (error) {
      console.error("Error getting referral earnings by user ID:", error);
      throw error;
    }
  }
  async getUnclaimedReferralEarnings(userId) {
    try {
      return db.select().from(referralEarnings).where(and(
        eq(referralEarnings.userId, userId),
        eq(referralEarnings.claimed, false)
      )).orderBy(desc(referralEarnings.createdAt));
    } catch (error) {
      console.error("Error getting unclaimed referral earnings:", error);
      throw error;
    }
  }
  // Update resource eggs - this modifies the eggs count for a user
  async updateResourceEggs(userId, eggAmount) {
    try {
      const userResources = await this.getResourcesByUserId(userId);
      if (!userResources) {
        throw new Error("User resources not found");
      }
      const currentEggs = userResources.eggs;
      const newEggAmount = currentEggs + eggAmount;
      await this.updateResources(userId, {
        eggs: newEggAmount
      });
    } catch (error) {
      console.error("Error updating resource eggs:", error);
      throw error;
    }
  }
  // Update resource wheat - this modifies the wheat bags count for a user
  async updateResourceWheat(userId, wheatAmount) {
    try {
      const userResources = await this.getResourcesByUserId(userId);
      if (!userResources) {
        throw new Error("User resources not found");
      }
      const currentWheat = userResources.wheatBags;
      const newWheatAmount = currentWheat + wheatAmount;
      await this.updateResources(userId, {
        wheatBags: newWheatAmount
      });
    } catch (error) {
      console.error("Error updating resource wheat:", error);
      throw error;
    }
  }
  // Update resource water - this modifies the water buckets count for a user
  async updateResourceWater(userId, waterAmount) {
    try {
      const userResources = await this.getResourcesByUserId(userId);
      if (!userResources) {
        throw new Error("User resources not found");
      }
      const currentWater = userResources.waterBuckets;
      const newWaterAmount = currentWater + waterAmount;
      await this.updateResources(userId, {
        waterBuckets: newWaterAmount
      });
    } catch (error) {
      console.error("Error updating resource water:", error);
      throw error;
    }
  }
  // Update user's extra spins - different from updateUserExtraSpins to handle different parameter names
  async updateExtraSpinsAvailable(userId, extraSpins) {
    try {
      return this.updateUserExtraSpins(userId, extraSpins);
    } catch (error) {
      console.error("Error updating user's extra spins:", error);
      throw error;
    }
  }
  async claimReferralEarning(earningId) {
    try {
      const [earning] = await db.select().from(referralEarnings).where(eq(referralEarnings.id, earningId));
      if (!earning) {
        throw new Error("Referral earning not found");
      }
      if (earning.claimed) {
        throw new Error("Referral earning already claimed");
      }
      await this.updateUserBalance(earning.userId, parseFloat(earning.amount.toString()));
      const [updated] = await db.update(referralEarnings).set({ claimed: true }).where(eq(referralEarnings.id, earningId)).returning();
      return updated;
    } catch (error) {
      console.error("Error claiming referral earning:", error);
      throw error;
    }
  }
  // Milestone operations
  async createMilestoneReward(milestone) {
    try {
      const [newMilestone] = await db.insert(milestoneRewards).values(milestone).returning();
      return newMilestone;
    } catch (error) {
      console.error("Error creating milestone reward:", error);
      throw error;
    }
  }
  async getMilestoneRewardsByUserId(userId) {
    try {
      return db.select().from(milestoneRewards).where(eq(milestoneRewards.userId, userId)).orderBy(desc(milestoneRewards.createdAt));
    } catch (error) {
      console.error("Error getting milestone rewards by user ID:", error);
      throw error;
    }
  }
  async getUnclaimedMilestoneRewards(userId) {
    try {
      return db.select().from(milestoneRewards).where(and(
        eq(milestoneRewards.userId, userId),
        eq(milestoneRewards.claimed, false)
      )).orderBy(desc(milestoneRewards.createdAt));
    } catch (error) {
      console.error("Error getting unclaimed milestone rewards:", error);
      throw error;
    }
  }
  async claimMilestoneReward(milestoneId) {
    try {
      const [milestone] = await db.select().from(milestoneRewards).where(eq(milestoneRewards.id, milestoneId));
      if (!milestone) {
        throw new Error("Milestone reward not found");
      }
      if (milestone.claimed) {
        throw new Error("Milestone reward already claimed");
      }
      await this.updateUserBalance(milestone.userId, parseFloat(milestone.reward.toString()));
      const now = /* @__PURE__ */ new Date();
      const [updated] = await db.update(milestoneRewards).set({
        claimed: true,
        claimedAt: now
      }).where(eq(milestoneRewards.id, milestoneId)).returning();
      return updated;
    } catch (error) {
      console.error("Error claiming milestone reward:", error);
      throw error;
    }
  }
  // Salary operations
  async createSalaryPayment(salary) {
    try {
      const [newSalary] = await db.insert(salaryPayments).values(salary).returning();
      return newSalary;
    } catch (error) {
      console.error("Error creating salary payment:", error);
      throw error;
    }
  }
  async getSalaryPaymentsByUserId(userId) {
    try {
      return db.select().from(salaryPayments).where(eq(salaryPayments.userId, userId)).orderBy(desc(salaryPayments.paidAt));
    } catch (error) {
      console.error("Error getting salary payments by user ID:", error);
      throw error;
    }
  }
  // Daily reward operations
  async createDailyReward(reward) {
    try {
      const [newReward] = await db.insert(dailyRewards).values(reward).returning();
      return newReward;
    } catch (error) {
      console.error("Error creating daily reward:", error);
      throw error;
    }
  }
  async getDailyRewardsByUserId(userId) {
    try {
      return db.select().from(dailyRewards).where(eq(dailyRewards.userId, userId)).orderBy(desc(dailyRewards.createdAt));
    } catch (error) {
      console.error("Error getting daily rewards by user ID:", error);
      throw error;
    }
  }
  async claimDailyReward(rewardId) {
    try {
      const [reward] = await db.select().from(dailyRewards).where(eq(dailyRewards.id, rewardId));
      if (!reward) {
        throw new Error("Daily reward not found");
      }
      if (reward.claimed) {
        throw new Error("Daily reward already claimed");
      }
      const userId = reward.userId;
      if (reward.eggs > 0) {
        const resource = await this.getResourcesByUserId(userId);
        await this.updateResources(userId, {
          eggs: resource.eggs + reward.eggs
        });
      }
      const usdtAmount = reward.usdt ? parseFloat(reward.usdt.toString()) : 0;
      if (usdtAmount > 0) {
        await this.updateUserBalance(userId, usdtAmount);
      }
      const [updated] = await db.update(dailyRewards).set({ claimed: true }).where(eq(dailyRewards.id, rewardId)).returning();
      return updated;
    } catch (error) {
      console.error("Error claiming daily reward:", error);
      throw error;
    }
  }
  async getCurrentDailyReward(userId) {
    try {
      const user = await this.getUser(userId);
      if (!user) {
        throw new Error("User not found");
      }
      const today = /* @__PURE__ */ new Date();
      today.setHours(0, 0, 0, 0);
      const [existingReward] = await db.select().from(dailyRewards).where(and(
        eq(dailyRewards.userId, userId),
        sql`DATE(${dailyRewards.createdAt}) = CURRENT_DATE`
      )).orderBy(desc(dailyRewards.createdAt));
      if (existingReward) {
        return existingReward;
      }
      let streak = user.currentStreak || 0;
      const lastRewardDate = user.lastDailyRewardAt;
      if (lastRewardDate) {
        const yesterday = /* @__PURE__ */ new Date();
        yesterday.setDate(yesterday.getDate() - 1);
        yesterday.setHours(0, 0, 0, 0);
        const lastRewardDay = new Date(lastRewardDate);
        lastRewardDay.setHours(0, 0, 0, 0);
        if (lastRewardDay.getTime() >= yesterday.getTime()) {
          streak += 1;
          if (streak > 7) streak = 1;
        } else {
          streak = 1;
        }
      } else {
        streak = 1;
      }
      const rewardData = dailyRewardsByDay.find((r) => r.day === streak) || dailyRewardsByDay[0];
      const reward = await this.createDailyReward({
        userId,
        day: streak,
        eggs: rewardData.eggs,
        usdt: rewardData.usdt.toString(),
        claimed: false
      });
      await this.updateUserStreak(userId, streak);
      await this.updateLastDailyReward(userId, /* @__PURE__ */ new Date());
      return reward;
    } catch (error) {
      console.error("Error getting current daily reward:", error);
      throw error;
    }
  }
  // Boost operations
  async createBoost(boost) {
    try {
      const [newBoost] = await db.insert(activeBoosts).values(boost).returning();
      return newBoost;
    } catch (error) {
      console.error("Error creating boost:", error);
      throw error;
    }
  }
  async getActiveBoostsByUserId(userId) {
    try {
      return db.select().from(activeBoosts).where(and(
        eq(activeBoosts.userId, userId),
        sql`${activeBoosts.expiresAt} > NOW()`
      )).orderBy(desc(activeBoosts.expiresAt));
    } catch (error) {
      console.error("Error getting active boosts by user ID:", error);
      throw error;
    }
  }
  async getActiveEggBoost(userId) {
    try {
      const activeBoosts2 = await this.getActiveBoostsByUserId(userId);
      let highestMultiplier = 1;
      for (const boost of activeBoosts2) {
        if (boost.type === "egg_production" && parseFloat(boost.multiplier.toString()) > highestMultiplier) {
          highestMultiplier = parseFloat(boost.multiplier.toString());
        }
      }
      return highestMultiplier;
    } catch (error) {
      console.error("Error getting active egg boost:", error);
      return 1;
    }
  }
  // Spin operations
  async createSpinHistory(spin) {
    try {
      console.log("[Storage] Creating spin history:", spin);
      const [record] = await db.insert(spinHistory).values(spin).returning();
      return record;
    } catch (error) {
      console.error("[Storage] Error creating spin history:", error);
      throw error;
    }
  }
  async getSpinHistoryByUserId(userId) {
    try {
      console.log(`[Storage] Fetching spin history for user ${userId}`);
      return db.select().from(spinHistory).where(eq(spinHistory.userId, userId)).orderBy(desc(spinHistory.createdAt));
    } catch (error) {
      console.error("[Storage] Error getting spin history:", error);
      throw error;
    }
  }
  async updateUserLastSpin(userId) {
    try {
      console.log(`[Storage] Updating last spin time for user ${userId}`);
      await db.update(users).set({ lastSpinAt: /* @__PURE__ */ new Date() }).where(eq(users.id, userId));
    } catch (error) {
      console.error("[Storage] Error updating last spin time:", error);
      throw error;
    }
  }
  async updateUserExtraSpins(userId, spins) {
    try {
      console.log(`[Storage] Updating extra spins for user ${userId} to ${spins}`);
      await db.update(users).set({ extraSpinsAvailable: spins }).where(eq(users.id, userId));
    } catch (error) {
      console.error("[Storage] Error updating extra spins:", error);
      throw error;
    }
  }
  // Spin Rewards Configuration methods
  async createSpinReward(reward) {
    try {
      console.log("[Storage] Creating spin reward configuration:", reward);
      const [newReward] = await db.insert(spinRewards).values({
        ...reward,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      }).returning();
      return newReward;
    } catch (error) {
      console.error("[Storage] Error creating spin reward:", error);
      throw error;
    }
  }
  async getSpinRewardsByType(spinType) {
    try {
      console.log(`[Storage] Fetching spin rewards for type ${spinType}`);
      const results = await db.select().from(spinRewards).where(eq(spinRewards.spinType, spinType));
      console.log(`[Storage] Found ${results.length} ${spinType} spin rewards`);
      return results;
    } catch (error) {
      console.error("[Storage] Error fetching spin rewards by type:", error);
      throw error;
    }
  }
  async updateSpinReward(id, updates) {
    try {
      console.log(`[Storage] Updating spin reward ${id}:`, updates);
      const [updatedReward] = await db.update(spinRewards).set({
        ...updates,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq(spinRewards.id, id)).returning();
      return updatedReward;
    } catch (error) {
      console.error("[Storage] Error updating spin reward:", error);
      throw error;
    }
  }
  async deleteSpinReward(id) {
    try {
      console.log(`[Storage] Deleting spin reward ${id}`);
      await db.delete(spinRewards).where(eq(spinRewards.id, id));
    } catch (error) {
      console.error("[Storage] Error deleting spin reward:", error);
      throw error;
    }
  }
  // Achievement badge methods
  async getAllAchievementBadges() {
    try {
      return db.select().from(achievementBadges);
    } catch (error) {
      console.error("[Storage] Error getting all achievement badges:", error);
      throw error;
    }
  }
  async getAchievementBadgeByCode(code) {
    try {
      const [badge] = await db.select().from(achievementBadges).where(eq(achievementBadges.code, code));
      return badge;
    } catch (error) {
      console.error(`[Storage] Error getting achievement badge by code ${code}:`, error);
      throw error;
    }
  }
  async createAchievementBadge(badge) {
    try {
      const [newBadge] = await db.insert(achievementBadges).values(badge).returning();
      return newBadge;
    } catch (error) {
      console.error("[Storage] Error creating achievement badge:", error);
      throw error;
    }
  }
  async getUserAchievements(userId) {
    try {
      return db.select().from(userAchievements).where(eq(userAchievements.userId, userId));
    } catch (error) {
      console.error(`[Storage] Error getting achievements for user ${userId}:`, error);
      throw error;
    }
  }
  async getUserAchievementsByBadgeId(userId, badgeId) {
    try {
      const [achievement] = await db.select().from(userAchievements).where(and(
        eq(userAchievements.userId, userId),
        eq(userAchievements.badgeId, badgeId)
      ));
      return achievement;
    } catch (error) {
      console.error(`[Storage] Error getting user achievement for user ${userId} and badge ${badgeId}:`, error);
      throw error;
    }
  }
  async createUserAchievement(achievement) {
    try {
      const [newAchievement] = await db.insert(userAchievements).values(achievement).returning();
      return newAchievement;
    } catch (error) {
      console.error("[Storage] Error creating user achievement:", error);
      throw error;
    }
  }
  async updateUserAchievement(id, updates) {
    try {
      const [updatedAchievement] = await db.update(userAchievements).set(updates).where(eq(userAchievements.id, id)).returning();
      return updatedAchievement;
    } catch (error) {
      console.error(`[Storage] Error updating user achievement ${id}:`, error);
      throw error;
    }
  }
  async getCompletedUserAchievements(userId) {
    try {
      return db.select().from(userAchievements).where(and(
        eq(userAchievements.userId, userId),
        eq(userAchievements.isComplete, true)
      ));
    } catch (error) {
      console.error(`[Storage] Error getting completed achievements for user ${userId}:`, error);
      throw error;
    }
  }
  async initializeAchievementBadges() {
    try {
      console.log("[Storage] Initializing achievement badges...");
      const existingBadges = await this.getAllAchievementBadges();
      if (existingBadges.length > 0) {
        console.log(`[Storage] ${existingBadges.length} achievement badges already exist, skipping initialization`);
        return;
      }
      for (const badgeDef of DEFAULT_ACHIEVEMENT_BADGES) {
        await this.createAchievementBadge({
          code: badgeDef.code,
          name: badgeDef.name,
          description: badgeDef.description,
          category: badgeDef.category,
          rarity: badgeDef.rarity,
          threshold: badgeDef.threshold,
          iconSvg: badgeDef.iconSvg
        });
      }
      console.log(`[Storage] Successfully initialized ${DEFAULT_ACHIEVEMENT_BADGES.length} achievement badges`);
    } catch (error) {
      console.error("[Storage] Error initializing achievement badges:", error);
      throw error;
    }
  }
  async initializeSpinRewards() {
    try {
      console.log("[Storage] Initializing spin rewards...");
      const existingDailyRewards = await this.getSpinRewardsByType("daily");
      const existingSuperRewards = await this.getSpinRewardsByType("super");
      if (existingDailyRewards.length === 0) {
        console.log("[Storage] No daily spin rewards found, initializing...");
        for (const rewardConfig of dailySpinRewards) {
          const { reward, probability } = rewardConfig;
          await this.createSpinReward({
            spinType: "daily",
            rewardType: reward.type,
            amount: reward.amount.toString(),
            chickenType: reward.chickenType,
            probability: probability.toString()
          });
        }
        console.log(`[Storage] Successfully initialized ${dailySpinRewards.length} daily spin rewards`);
      } else {
        console.log(`[Storage] Found ${existingDailyRewards.length} daily spin rewards, skipping initialization`);
      }
      if (existingSuperRewards.length === 0) {
        console.log("[Storage] No super jackpot rewards found, initializing...");
        for (const rewardConfig of superJackpotRewards) {
          const { reward, probability } = rewardConfig;
          await this.createSpinReward({
            spinType: "super",
            rewardType: reward.type,
            amount: reward.amount.toString(),
            chickenType: reward.chickenType,
            probability: probability.toString()
          });
        }
        console.log(`[Storage] Successfully initialized ${superJackpotRewards.length} super jackpot rewards`);
      } else {
        console.log(`[Storage] Found ${existingSuperRewards.length} super jackpot rewards, skipping initialization`);
      }
    } catch (error) {
      console.error("[Storage] Error initializing spin rewards:", error);
      throw error;
    }
  }
  // Telegram ID methods
  async updateUserTelegramId(userId, telegramId) {
    try {
      console.log(`[Storage] Updating Telegram ID for user ${userId} to ${telegramId}`);
      await db.update(users).set({ telegramId }).where(eq(users.id, userId));
      console.log(`[Storage] Successfully updated Telegram ID for user ${userId}`);
    } catch (error) {
      console.error(`[Storage] Error updating Telegram ID for user ${userId}:`, error);
      throw error;
    }
  }
  async getAllUsersTelegramIds() {
    try {
      console.log("[Storage] Fetching all users with their Telegram IDs");
      const result = await db.select({
        id: users.id,
        username: users.username,
        telegramId: users.telegramId
      }).from(users).orderBy(users.id);
      console.log(`[Storage] Found ${result.length} users`);
      return result;
    } catch (error) {
      console.error("[Storage] Error fetching users with Telegram IDs:", error);
      throw error;
    }
  }
};
var storage = new DatabaseStorage();
var mysteryBoxTypes2 = {
  basic: {
    price: 5,
    name: "Basic Mystery Box",
    description: "A basic mystery box with common rewards",
    rewards: {
      eggs: {
        ranges: [
          { min: 5, max: 10, chance: 0.5 },
          // 50% chance
          { min: 11, max: 15, chance: 0.4 },
          // 40% chance
          { min: 16, max: 20, chance: 0.1 }
          // 10% chance
        ]
      }
    },
    rarityDistribution: {
      common: 0.9,
      uncommon: 0.1
    }
  },
  standard: {
    price: 10,
    name: "Standard Mystery Box",
    description: "A standard mystery box with balanced rewards",
    rewards: {
      eggs: {
        ranges: [
          { min: 10, max: 20, chance: 0.45 },
          // 45% chance
          { min: 21, max: 30, chance: 0.35 },
          // 35% chance
          { min: 31, max: 40, chance: 0.2 }
          // 20% chance
        ]
      },
      chicken: {
        types: ["baby"],
        chance: 0.05
        // 5% chance for baby chicken
      }
    },
    rarityDistribution: {
      common: 0.7,
      uncommon: 0.2,
      rare: 0.1
    }
  },
  advanced: {
    price: 20,
    name: "Advanced Mystery Box",
    description: "An advanced mystery box with better rewards",
    rewards: {
      eggs: {
        ranges: [
          { min: 20, max: 40, chance: 0.4 },
          // 40% chance
          { min: 41, max: 60, chance: 0.35 },
          // 35% chance
          { min: 61, max: 80, chance: 0.2 }
          // 20% chance
        ]
      },
      chicken: {
        types: ["baby", "regular"],
        chance: 0.08
        // 8% chance for chicken
      },
      usdt: {
        ranges: [
          { amount: 2, chance: 0.02 }
          // 2% chance for USDT
        ]
      },
      resources: {
        wheat: {
          ranges: [{ min: 1, max: 5, chance: 0.5 }]
        },
        water: {
          ranges: [{ min: 1, max: 5, chance: 0.5 }]
        }
      }
    },
    rarityDistribution: {
      common: 0.5,
      uncommon: 0.3,
      rare: 0.2
    }
  },
  legendary: {
    price: 50,
    name: "Legendary Mystery Box",
    description: "A legendary mystery box with the best possible rewards",
    rewards: {
      eggs: {
        ranges: [
          { min: 50, max: 100, chance: 0.35 },
          // 35% chance
          { min: 101, max: 150, chance: 0.3 },
          // 30% chance
          { min: 151, max: 200, chance: 0.22 }
          // 22% chance
        ]
      },
      chicken: {
        types: ["regular", "golden"],
        chance: 0.1
        // 10% chance for better chickens
      },
      usdt: {
        ranges: [
          { amount: 5, chance: 0.03 }
          // 3% chance for USDT
        ]
      },
      resources: {
        wheat: {
          ranges: [{ min: 5, max: 10, chance: 0.5 }]
        },
        water: {
          ranges: [{ min: 5, max: 10, chance: 0.5 }]
        }
      }
    },
    rarityDistribution: {
      common: 0.2,
      uncommon: 0.3,
      rare: 0.4,
      epic: 0.1
    }
  }
};

// server/auth.ts
var isAuthenticated = (req, res, next) => {
  console.log("[Auth Middleware] Checking authentication");
  console.log("[Auth Middleware] Session:", req.session);
  console.log("[Auth Middleware] User:", req.user);
  console.log("[Auth Middleware] IsAuthenticated:", req.isAuthenticated());
  if (req.isAuthenticated()) {
    console.log("[Auth Middleware] Authentication successful for user:", req.user?.username);
    return next();
  }
  console.log("[Auth Middleware] Authentication failed - no valid session");
  res.status(401).json({ message: "Not authenticated" });
};
function setupAuth(app2) {
  if (!process.env.SESSION_SECRET) {
    throw new Error("SESSION_SECRET environment variable is required");
  }
  const sessionSettings = {
    secret: process.env.SESSION_SECRET,
    resave: true,
    // Changed to true to ensure session is saved
    saveUninitialized: true,
    // Changed to true to create session for all requests
    store: storage.sessionStore,
    cookie: {
      secure: process.env.NODE_ENV === "production",
      sameSite: process.env.NODE_ENV === "production" ? "strict" : "lax",
      maxAge: 30 * 24 * 60 * 60 * 1e3,
      // 30 days
      path: "/",
      httpOnly: true
    },
    name: "chickfarms.sid",
    rolling: true
    // Resets the cookie maxAge on every response
  };
  console.log("[Auth Setup] Session settings:", {
    ...sessionSettings,
    store: "PostgreSQLStore",
    cookie: sessionSettings.cookie,
    nodeEnv: process.env.NODE_ENV
  });
  if (process.env.NODE_ENV === "production") {
    app2.set("trust proxy", 1);
  }
  const sessionMiddleware = session2(sessionSettings);
  app2.use(sessionMiddleware);
  app2.use(passport.initialize());
  app2.use(passport.session());
  passport.use(
    new LocalStrategy(async (username, password, done) => {
      try {
        console.log("[Auth] Attempting login for user:", username);
        const user = await storage.getUserByUsername(username);
        if (!user) {
          console.log("[Auth] User not found:", username);
          return done(null, false, { message: "Invalid credentials" });
        }
        const passwordMatch = await comparePasswords(password, user.password);
        console.log("[Auth] Password match:", passwordMatch);
        if (!passwordMatch) {
          return done(null, false, { message: "Invalid credentials" });
        }
        console.log("[Auth] Login successful for user:", username);
        return done(null, user);
      } catch (err) {
        console.error("[Auth] Login error:", err);
        return done(err);
      }
    })
  );
  passport.serializeUser((user, done) => {
    console.log("[Auth] Serializing user:", user.id);
    done(null, user.id);
  });
  passport.deserializeUser(async (id, done) => {
    try {
      console.log("[Auth] Deserializing user:", id);
      const user = await storage.getUser(id);
      if (!user) {
        console.log("[Auth] User not found during deserialization:", id);
        return done(null, false);
      }
      console.log("[Auth] User deserialized successfully:", user.username);
      done(null, user);
    } catch (err) {
      console.error("[Auth] Deserialization error:", err);
      done(err);
    }
  });
  app2.post("/api/login", (req, res, next) => {
    console.log("[Auth] Login attempt for:", req.body.username);
    passport.authenticate("local", (err, user, info) => {
      if (err) {
        console.error("[Auth] Login error:", err);
        return next(err);
      }
      if (!user) {
        console.log("[Auth] Login failed for:", req.body.username);
        return res.status(401).json({ message: info?.message || "Invalid credentials" });
      }
      req.login(user, (err2) => {
        if (err2) {
          console.error("[Auth] Session creation error:", err2);
          return next(err2);
        }
        console.log("[Auth] Login successful for:", user.username);
        console.log("[Auth] Session ID:", req.sessionID);
        console.log("[Auth] Session:", req.session);
        req.session.save((err3) => {
          if (err3) {
            console.error("[Auth] Session save error:", err3);
            return next(err3);
          }
          res.json({
            id: user.id,
            username: user.username,
            isAdmin: user.isAdmin,
            usdtBalance: user.usdtBalance,
            referralCode: user.referralCode,
            totalReferralEarnings: user.totalReferralEarnings,
            totalTeamEarnings: user.totalTeamEarnings,
            lastDailyRewardAt: user.lastDailyRewardAt,
            currentStreak: user.currentStreak,
            lastSpinAt: user.lastSpinAt,
            extraSpinsAvailable: user.extraSpinsAvailable
          });
        });
      });
    })(req, res, next);
  });
  app2.get("/api/user", (req, res) => {
    console.log("[Auth] User check - Session:", req.session);
    console.log("[Auth] User check - Is authenticated:", req.isAuthenticated());
    console.log("[Auth] User check - User:", req.user);
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Not authenticated" });
    }
    const user = req.user;
    res.json({
      id: user.id,
      username: user.username,
      isAdmin: user.isAdmin,
      usdtBalance: user.usdtBalance,
      referralCode: user.referralCode,
      totalReferralEarnings: user.totalReferralEarnings,
      totalTeamEarnings: user.totalTeamEarnings,
      lastDailyRewardAt: user.lastDailyRewardAt,
      currentStreak: user.currentStreak,
      lastSpinAt: user.lastSpinAt,
      extraSpinsAvailable: user.extraSpinsAvailable,
      referralCount: user.referralCount || 0
    });
  });
  app2.post("/api/logout", (req, res, next) => {
    const username = req.user?.username;
    console.log("[Auth] Logout attempt for:", username);
    req.logout((err) => {
      if (err) {
        console.error("[Auth] Logout error:", err);
        return next(err);
      }
      req.session.destroy((err2) => {
        if (err2) {
          console.error("[Auth] Session destruction error:", err2);
          return next(err2);
        }
        res.clearCookie("chickfarms.sid", {
          path: "/",
          httpOnly: true,
          secure: process.env.NODE_ENV === "production",
          sameSite: process.env.NODE_ENV === "production" ? "strict" : "lax"
        });
        console.log("[Auth] Logout successful for:", username);
        res.sendStatus(200);
      });
    });
  });
  app2.post("/api/register", async (req, res, next) => {
    try {
      console.log("[Auth] Registration attempt for:", req.body.username);
      const existingUser = await storage.getUserByUsername(req.body.username);
      if (existingUser) {
        console.log("[Auth] Registration failed - username exists:", req.body.username);
        return res.status(400).json({ message: "Username already exists" });
      }
      const hashedPassword = await hashPassword(req.body.password);
      const user = await storage.createUser({
        ...req.body,
        password: hashedPassword
      });
      console.log("[Auth] Registration successful for:", user.username);
      req.login(user, (err) => {
        if (err) return next(err);
        req.session.save((err2) => {
          if (err2) {
            console.error("[Auth] Session save error after registration:", err2);
            return next(err2);
          }
          res.status(201).json({
            id: user.id,
            username: user.username,
            isAdmin: user.isAdmin,
            usdtBalance: user.usdtBalance,
            referralCode: user.referralCode,
            totalReferralEarnings: user.totalReferralEarnings,
            totalTeamEarnings: user.totalTeamEarnings,
            lastDailyRewardAt: user.lastDailyRewardAt,
            currentStreak: user.currentStreak,
            lastSpinAt: user.lastSpinAt,
            extraSpinsAvailable: user.extraSpinsAvailable,
            referralCount: user.referralCount || 0
          });
        });
      });
    } catch (err) {
      console.error("[Auth] Registration error:", err);
      next(err);
    }
  });
}

// server/routes-nowpayments.ts
import { z as z2 } from "zod";

// server/config.ts
var config = {
  // Database configuration
  database: {
    url: process.env.DATABASE_URL || ""
  },
  // API and application URLs
  urls: {
    api: process.env.API_URL || (process.env.DOMAIN ? `https://${process.env.DOMAIN}` : process.env.VERCEL_URL ? `https://${process.env.VERCEL_URL}` : process.env.REPL_SLUG && process.env.REPL_OWNER ? `https://${process.env.REPL_SLUG}.${process.env.REPL_OWNER}.repl.co` : "http://localhost:5000"),
    app: process.env.APP_URL || (process.env.DOMAIN ? `https://${process.env.DOMAIN}` : process.env.VERCEL_URL ? `https://${process.env.VERCEL_URL}` : process.env.REPL_SLUG && process.env.REPL_OWNER ? `https://${process.env.REPL_SLUG}.${process.env.REPL_OWNER}.repl.co` : "http://localhost:5000"),
    // Production domain for NOWPayments callbacks
    productionDomain: process.env.VERCEL_URL ? `https://${process.env.VERCEL_URL}` : process.env.DOMAIN ? `https://${process.env.DOMAIN}` : "https://chickfarms.com"
  },
  // Environment settings
  env: {
    isProduction: process.env.NODE_ENV === "production",
    isDevelopment: process.env.NODE_ENV !== "production"
  },
  // NOWPayments configuration
  nowpayments: {
    apiKey: process.env.NOWPAYMENTS_API_KEY || null,
    ipnSecretKey: process.env.NOWPAYMENTS_IPN_SECRET_KEY || null,
    callbackDomain: process.env.VERCEL_URL ? `https://${process.env.VERCEL_URL}` : process.env.DOMAIN ? `https://${process.env.DOMAIN}` : "https://chickfarms.com"
  }
};

// server/services/nowpayments.ts
import axios from "axios";
import CryptoJS from "crypto-js";
var NOWPaymentsService = class {
  apiKey;
  ipnSecret;
  baseUrl;
  isMockMode;
  constructor() {
    this.apiKey = process.env.NOWPAYMENTS_API_KEY || "";
    this.ipnSecret = process.env.NOWPAYMENTS_IPN_SECRET_KEY || "";
    this.isMockMode = false;
    this.baseUrl = "https://api.nowpayments.io/v1";
    if (!this.apiKey) {
      console.error("[NOWPayments] API key is missing");
    }
    if (!this.ipnSecret) {
      console.error("[NOWPayments] IPN secret key is missing");
    }
  }
  /**
   * Get API request headers
   */
  getHeaders() {
    return {
      "x-api-key": this.apiKey,
      "Content-Type": "application/json"
    };
  }
  /**
   * Check if API keys are configured
   */
  isConfigured() {
    return !!this.apiKey && !!this.ipnSecret;
  }
  /**
   * Get API status
   */
  async getStatus() {
    try {
      if (!this.apiKey) {
        return { status: "error", message: "API key not configured" };
      }
      const response = await axios.get(`${this.baseUrl}/status`, {
        headers: this.getHeaders()
      });
      return response.data;
    } catch (error) {
      console.error("[NOWPayments] Error checking status:", error.response?.data || error.message);
      return {
        status: "error",
        message: error.response?.data?.message || error.message
      };
    }
  }
  /**
   * Get minimum payment amount for a specific currency
   */
  async getMinimumPaymentAmount(currency) {
    try {
      const response = await axios.get(`${this.baseUrl}/min-amount?currency=${currency}`, {
        headers: this.getHeaders()
      });
      return response.data.min_amount || 1;
    } catch (error) {
      console.error("[NOWPayments] Error getting minimum amount:", error.response?.data || error.message);
      return 1;
    }
  }
  /**
   * Get available currencies
   */
  async getAvailableCurrencies() {
    try {
      const response = await axios.get(`${this.baseUrl}/currencies`, {
        headers: this.getHeaders()
      });
      return response.data.currencies || [];
    } catch (error) {
      console.error("[NOWPayments] Error getting currencies:", error.response?.data || error.message);
      return ["usdttrc20"];
    }
  }
  /**
   * Create a payment using the invoice API
   */
  async createPayment(userId, amount, description, currency = "USDT") {
    currency = currency.toLowerCase();
    if (currency === "usdt") {
      currency = "usdttrc20";
    }
    try {
      const user = await storage.getUser(userId);
      if (!user) {
        throw new Error("User not found");
      }
      const baseURL = config.nowpayments.callbackDomain || config.urls.productionDomain || config.urls.api || "http://localhost:5000";
      const callbackUrl = `${baseURL}/api/ipn/nowpayments`;
      const successUrl = `${baseURL}/wallet?payment=success`;
      const cancelUrl = `${baseURL}/wallet?payment=cancelled`;
      const orderId = `user_${userId}_${Date.now()}`;
      console.log("[NOWPayments] Creating invoice with NOWPayments API", {
        amount,
        currency,
        callbackUrl,
        orderId,
        successUrl,
        cancelUrl
      });
      try {
        const invoiceResponse = await axios.post(
          `${this.baseUrl}/invoice`,
          {
            price_amount: amount,
            price_currency: currency.toLowerCase(),
            // No pay_currency parameter to allow user to pay in any cryptocurrency
            order_id: orderId,
            order_description: description,
            ipn_callback_url: callbackUrl,
            success_url: successUrl,
            cancel_url: cancelUrl,
            is_fee_paid_by_user: true,
            is_fixed_rate: true
            // Fixes exchange rate
          },
          { headers: this.getHeaders() }
        );
        console.log("[NOWPayments] Invoice response:", invoiceResponse.data);
        const paymentResponse = {
          payment_id: invoiceResponse.data.id,
          payment_status: "waiting",
          pay_address: invoiceResponse.data.pay_address || "",
          price_amount: invoiceResponse.data.price_amount,
          price_currency: invoiceResponse.data.price_currency,
          pay_amount: invoiceResponse.data.pay_amount || 0,
          pay_currency: invoiceResponse.data.pay_currency,
          order_id: orderId,
          order_description: description,
          ipn_callback_url: callbackUrl,
          created_at: invoiceResponse.data.created_at,
          updated_at: invoiceResponse.data.created_at,
          purchase_id: invoiceResponse.data.id,
          payment_url: invoiceResponse.data.invoice_url,
          // Use invoice_url here
          invoice_id: invoiceResponse.data.id
        };
        return paymentResponse;
      } catch (apiError) {
        console.error("[NOWPayments] API error:", apiError.response?.data || apiError.message);
        throw new Error(`NOWPayments API error: ${apiError.response?.data?.message || apiError.message}`);
      }
    } catch (error) {
      console.error("[NOWPayments] Error creating payment invoice:", error);
      throw new Error(error.message || "Failed to create payment invoice");
    }
  }
  /**
   * Process IPN notification
   */
  async processIPNNotification(payload) {
    try {
      const orderIdParts = payload.order_id.split("_");
      if (orderIdParts.length < 2) {
        throw new Error("Invalid order ID format");
      }
      const userId = parseInt(orderIdParts[1], 10);
      if (isNaN(userId)) {
        throw new Error("Invalid user ID in order ID");
      }
      const user = await storage.getUser(userId);
      if (!user) {
        throw new Error(`User with ID ${userId} not found`);
      }
      const existingTransaction = await this.findTransactionByPaymentId(payload.payment_id);
      let status = "pending";
      switch (payload.payment_status) {
        case "finished":
        case "confirmed":
          status = "completed";
          if (!existingTransaction || existingTransaction.status !== "completed") {
            await storage.updateUserBalance(userId, payload.price_amount);
            console.log(`[NOWPayments] Updated user balance for user ${userId} with amount ${payload.price_amount}`);
          }
          break;
        case "failed":
        case "expired":
        case "refunded":
          status = "failed";
          break;
        default:
          break;
      }
      if (existingTransaction) {
        await storage.updateTransactionStatus(payload.payment_id, status);
        return existingTransaction;
      } else {
        const transaction = await storage.createTransaction(
          userId,
          "deposit",
          payload.price_amount,
          payload.payment_id,
          0,
          JSON.stringify(payload)
        );
        return transaction;
      }
    } catch (error) {
      console.error("[NOWPayments] Error processing IPN notification:", error);
      throw new Error("Failed to process IPN notification: " + error.message);
    }
  }
  /**
   * Find transaction by payment ID
   */
  async findTransactionByPaymentId(paymentId) {
    try {
      const transaction = await storage.getTransactionByTransactionId(paymentId);
      return transaction;
    } catch (error) {
      console.error("[NOWPayments] Error finding transaction:", error);
      return null;
    }
  }
  /**
   * Verify IPN signature
   */
  verifyIPNSignature(payload, signature) {
    try {
      const hmac = CryptoJS.HmacSHA512(payload, this.ipnSecret);
      const calculatedSignature = hmac.toString(CryptoJS.enc.Hex);
      return calculatedSignature === signature;
    } catch (error) {
      console.error("[NOWPayments] Error verifying IPN signature:", error);
      return false;
    }
  }
  /**
   * Get payment status
   */
  async getPaymentStatus(paymentId) {
    try {
      const response = await axios.get(`${this.baseUrl}/payment/${paymentId}`, {
        headers: this.getHeaders()
      });
      return response.data;
    } catch (error) {
      console.error("[NOWPayments] Error getting payment status:", error.response?.data || error.message);
      throw new Error(`Failed to get payment status: ${error.response?.data?.message || error.message}`);
    }
  }
  /**
   * Map NOWPayments status to our transaction status
   */
  mapPaymentStatusToTransactionStatus(paymentStatus) {
    switch (paymentStatus) {
      case "finished":
      case "confirmed":
        return "completed";
      case "waiting":
      case "confirming":
      case "sending":
        return "pending";
      case "failed":
      case "expired":
      case "refunded":
        return "failed";
      default:
        return "pending";
    }
  }
};
var nowPaymentsService = new NOWPaymentsService();

// server/routes-nowpayments.ts
var isNOWPaymentsConfigured = () => !!config.nowpayments.apiKey;
var isIPNSecretConfigured = () => !!config.nowpayments.ipnSecretKey;
async function registerRoutes(app2) {
  app2.get("/api/payments/status", async (req, res) => {
    try {
      const status = await nowPaymentsService.getStatus();
      res.json({
        status,
        apiKeyConfigured: isNOWPaymentsConfigured(),
        ipnSecretConfigured: isIPNSecretConfigured(),
        serviceConfigured: nowPaymentsService.isConfigured()
      });
    } catch (error) {
      console.error("Error checking NOWPayments status:", error);
      res.status(500).json({ error: "Failed to check payment service status" });
    }
  });
  app2.get("/api/public/payments/service-status", async (req, res) => {
    try {
      let serviceStatus = "unknown";
      const apiConfigured = isNOWPaymentsConfigured();
      const ipnConfigured = isIPNSecretConfigured();
      let errorMessage = null;
      let minAmount = 10;
      console.log("[Payment Service Status] ========= START PAYMENT STATUS CHECK =========");
      console.log("[Payment Service Status] Checking NOWPayments configuration...");
      console.log("[Payment Service Status] API key configured:", apiConfigured ? "YES" : "NO");
      console.log("[Payment Service Status] IPN secret configured:", ipnConfigured ? "YES" : "NO");
      console.log("[Payment Service Status] Request origin:", req.headers.origin || "Unknown");
      console.log("[Payment Service Status] User agent:", req.headers["user-agent"] || "Unknown");
      if (apiConfigured) {
        try {
          console.log("[Payment Service Status] Calling NOWPayments status API...");
          const status = await nowPaymentsService.getStatus();
          console.log("[Payment Service Status] Raw status response:", status);
          if (status.status === "error") {
            serviceStatus = "error";
            errorMessage = status.message || "Error connecting to payment service";
            console.error("[Payment Service Status] Error from status check:", errorMessage);
          } else {
            serviceStatus = status.status || "unknown";
            console.log("[Payment Service Status] Service status:", serviceStatus);
            if (serviceStatus !== "unknown" && serviceStatus !== "error") {
              try {
                console.log("[Payment Service Status] Getting minimum payment amount for usdttrc20...");
                minAmount = await nowPaymentsService.getMinimumPaymentAmount("usdttrc20");
                console.log("[Payment Service Status] Minimum payment amount:", minAmount);
              } catch (minAmountError) {
                console.error("[Payment Service Status] Failed to get minimum amount:", minAmountError);
              }
            }
          }
        } catch (error) {
          console.error("[Payment Service Status] Exception checking payment service:", error);
          serviceStatus = "error";
          errorMessage = error instanceof Error ? error.message : "Unknown error";
        }
      } else {
        console.log("[Payment Service Status] API key not configured, skipping status check");
      }
      const isReady = apiConfigured && ipnConfigured && serviceStatus !== "error";
      console.log("[Payment Service Status] Service ready status:", isReady ? "READY" : "NOT READY");
      console.log("[Payment Service Status] ========= END PAYMENT STATUS CHECK =========");
      res.json({
        apiConfigured,
        ipnConfigured,
        serviceStatus,
        error: errorMessage,
        ready: isReady,
        minAmount
      });
    } catch (error) {
      console.error("[Payment Service Status] Unexpected error:", error);
      res.status(500).json({
        error: "Failed to check payment service status",
        apiConfigured: isNOWPaymentsConfigured(),
        ipnConfigured: isIPNSecretConfigured(),
        serviceStatus: "error",
        ready: false
      });
    }
  });
  app2.post("/api/payments/create-payment", isAuthenticated, async (req, res) => {
    try {
      const schema = z2.object({
        amount: z2.number().positive(),
        description: z2.string().optional()
      });
      const result = schema.safeParse(req.body);
      if (!result.success) {
        return res.status(400).json({ error: "Invalid request parameters", details: result.error });
      }
      const { amount, description = "ChickFarms USDT deposit" } = result.data;
      const user = req.user;
      console.log(`Creating NOWPayments payment for user ${user.id}, amount: ${amount} USDT`);
      if (!nowPaymentsService.isConfigured()) {
        return res.status(503).json({
          error: "Payment service not configured",
          message: "The payment service is not properly configured. Please try again later."
        });
      }
      try {
        const payment = await nowPaymentsService.createPayment(
          user.id,
          amount,
          description
        );
        console.log(`Created payment with ID ${payment.payment_id}, payment URL: ${payment.payment_url}`);
        const transaction = await storage.createTransaction(
          user.id,
          "deposit",
          amount,
          payment.payment_id,
          0,
          JSON.stringify(payment)
        );
        console.log(`Created transaction record with ID ${transaction.id}`);
        return res.json({
          success: true,
          payment: {
            id: payment.payment_id,
            status: payment.payment_status,
            paymentUrl: payment.payment_url,
            amount,
            currency: "USDT",
            transactionId: transaction.id
          }
        });
      } catch (apiError) {
        console.error("Error creating NOWPayments payment:", apiError);
        return res.status(500).json({
          error: "Failed to create payment",
          message: apiError.message || "An error occurred while creating the payment"
        });
      }
    } catch (error) {
      console.error("Unexpected error in payment creation endpoint:", error);
      res.status(500).json({
        error: "Failed to create payment",
        message: error.message || "An unexpected error occurred"
      });
    }
  });
  app2.post("/api/ipn/nowpayments", async (req, res) => {
    try {
      console.log("[IPN] Received NOWPayments IPN callback");
      if (!isIPNSecretConfigured()) {
        console.error("[IPN] IPN secret key not configured");
        return res.status(503).json({ error: "IPN secret not configured" });
      }
      const signature = req.headers["x-nowpayments-sig"];
      if (!signature) {
        console.error("[IPN] Missing signature header");
        return res.status(400).json({ error: "Missing signature" });
      }
      const rawBody = JSON.stringify(req.body);
      console.log("[IPN] Raw body:", rawBody);
      const isValid = nowPaymentsService.verifyIPNSignature(rawBody, signature);
      if (!isValid) {
        console.error("[IPN] Invalid signature");
        return res.status(403).json({ error: "Invalid signature" });
      }
      console.log("[IPN] Signature verified successfully");
      const result = await nowPaymentsService.processIPNNotification(req.body);
      console.log("[IPN] IPN processed successfully:", result);
      return res.status(200).json({ status: "ok" });
    } catch (error) {
      console.error("[IPN] Error processing IPN:", error);
      return res.status(200).json({
        status: "error",
        message: error.message || "An error occurred while processing the IPN"
      });
    }
  });
  app2.get("/api/payments/status/:paymentId", isAuthenticated, async (req, res) => {
    try {
      const { paymentId } = req.params;
      const user = req.user;
      const transaction = await storage.getTransactionByTransactionId(paymentId);
      if (!transaction) {
        return res.status(404).json({ error: "Transaction not found" });
      }
      if (transaction.userId !== user.id && !user.isAdmin) {
        return res.status(403).json({ error: "Not authorized to view this transaction" });
      }
      let paymentStatus;
      try {
        paymentStatus = await nowPaymentsService.getPaymentStatus(paymentId);
      } catch (apiError) {
        console.error(`Error fetching payment status for ${paymentId}:`, apiError);
        return res.json({
          success: true,
          payment: {
            id: transaction.transactionId,
            status: transaction.status,
            amount: transaction.amount,
            createdAt: transaction.createdAt
          }
        });
      }
      const mappedStatus = nowPaymentsService.mapPaymentStatusToTransactionStatus(paymentStatus.payment_status);
      if (mappedStatus !== transaction.status) {
        await storage.updateTransactionStatus(paymentId, mappedStatus);
        if (mappedStatus === "completed" && transaction.status !== "completed") {
          await storage.updateUserBalance(user.id, parseFloat(transaction.amount));
          console.log(`Updated user ${user.id} balance with ${transaction.amount} USDT`);
        }
      }
      return res.json({
        success: true,
        payment: {
          id: paymentStatus.payment_id,
          status: paymentStatus.payment_status,
          mappedStatus,
          amount: paymentStatus.price_amount,
          payAddress: paymentStatus.pay_address,
          createdAt: paymentStatus.created_at,
          updatedAt: paymentStatus.updated_at
        }
      });
    } catch (error) {
      console.error("Error checking payment status:", error);
      res.status(500).json({
        error: "Failed to check payment status",
        message: error.message || "An unexpected error occurred"
      });
    }
  });
  app2.get("/api/payments/currencies", async (req, res) => {
    try {
      const currencies = await nowPaymentsService.getAvailableCurrencies();
      res.json({ currencies });
    } catch (error) {
      console.error("Error fetching available currencies:", error);
      res.status(500).json({ error: "Failed to fetch available currencies" });
    }
  });
  return app2;
}

// server/routes.ts
import { createServer } from "http";
import { z as z3 } from "zod";
import crypto from "crypto";
var isNOWPaymentsConfigured2 = () => !!config.nowpayments.apiKey;
var isIPNSecretConfigured2 = () => !!config.nowpayments.ipnSecretKey;
var isAdmin = (req, res, next) => {
  if (!req.isAuthenticated()) {
    console.log("[Admin Middleware] User not authenticated");
    return res.status(401).json({ error: "Not authenticated" });
  }
  if (!req.user || !req.user.isAdmin) {
    console.log("[Admin Middleware] Access denied, user is not an admin:", req.user?.username);
    return res.status(403).json({ error: "Access denied. Admin privileges required." });
  }
  console.log("[Admin Middleware] Admin access granted to:", req.user.username);
  next();
};
async function registerRoutes2(app2) {
  app2.get("/api/health", (req, res) => {
    res.json({
      status: "API is running",
      time: (/* @__PURE__ */ new Date()).toISOString(),
      env: process.env.NODE_ENV || "development",
      version: "1.0.0"
    });
  });
  setupAuth(app2);
  app2.get("/api/test", (req, res) => {
    console.log("[API] Test endpoint accessed");
    res.json({
      status: "ok",
      message: "API is working properly",
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      apiVersion: "1.0.0"
    });
  });
  app2.get("/api/test-health", (req, res) => {
    console.log("[API] Health test endpoint accessed");
    res.json({
      status: "OK",
      message: "Application is running correctly",
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      version: "1.0.0",
      paymentServiceAvailable: isNOWPaymentsConfigured2(),
      environment: process.env.NODE_ENV || "development"
    });
  });
  app2.get("/api/debug/spin-rewards", async (req, res) => {
    try {
      console.log("[DEBUG] Spin rewards debug endpoint accessed");
      let dailyRewards2 = await storage.getSpinRewardsByType("daily");
      let superRewards = await storage.getSpinRewardsByType("super");
      console.log("[DEBUG] Daily rewards from database:", dailyRewards2);
      console.log("[DEBUG] Super rewards from database:", superRewards);
      res.json({
        daily: dailyRewards2,
        super: superRewards,
        message: "This is a debug endpoint for testing spin rewards"
      });
    } catch (err) {
      console.error("[DEBUG] Error fetching spin rewards:", err);
      res.status(500).json({ error: "Failed to fetch spin rewards" });
    }
  });
  app2.get("/api/payments/status", async (req, res) => {
    try {
      const status = await nowPaymentsService.getStatus();
      res.json({
        status,
        apiKeyConfigured: isNOWPaymentsConfigured2(),
        ipnSecretConfigured: isIPNSecretConfigured2()
      });
    } catch (error) {
      console.error("Error checking NOWPayments status:", error);
      res.status(500).json({ error: "Failed to check payment service status" });
    }
  });
  app2.get("/api/public/payments/service-status", async (req, res) => {
    try {
      let serviceStatus = "unknown";
      const apiConfigured = isNOWPaymentsConfigured2();
      const ipnConfigured = isIPNSecretConfigured2();
      let errorMessage = null;
      let minAmount = 10;
      let apiStatus = "unknown";
      console.log("[Payment Service Status] ========= START PAYMENT STATUS CHECK =========");
      console.log("[Payment Service Status] Checking NOWPayments configuration...");
      console.log("[Payment Service Status] API key configured:", apiConfigured ? "YES" : "NO");
      console.log("[Payment Service Status] IPN secret configured:", ipnConfigured ? "YES" : "NO");
      console.log("[Payment Service Status] Request origin:", req.headers.origin || "Unknown");
      console.log("[Payment Service Status] User agent:", req.headers["user-agent"] || "Unknown");
      if (apiConfigured) {
        try {
          console.log("[Payment Service Status] Calling NOWPayments status API...");
          const status = await nowPaymentsService.getStatus();
          console.log("[Payment Service Status] Raw status response:", status);
          if (status.status === "error") {
            serviceStatus = "error";
            errorMessage = status.message || "Error connecting to payment service";
            console.error("[Payment Service Status] Error from status check:", errorMessage);
          } else {
            serviceStatus = status.status || "unknown";
            console.log("[Payment Service Status] Service status:", serviceStatus);
            if (serviceStatus !== "unknown" && serviceStatus !== "error") {
              try {
                console.log("[Payment Service Status] Getting minimum payment amount for usdttrc20...");
                minAmount = await nowPaymentsService.getMinimumPaymentAmount("usdttrc20");
                console.log("[Payment Service Status] Minimum payment amount:", minAmount);
              } catch (minAmountError) {
                console.error("[Payment Service Status] Failed to get minimum amount:", minAmountError);
              }
            }
          }
        } catch (error) {
          console.error("[Payment Service Status] Exception checking payment service:", error);
          serviceStatus = "error";
          errorMessage = error instanceof Error ? error.message : "Unknown error";
        }
      } else {
        console.log("[Payment Service Status] API key not configured, skipping status check");
      }
      const isReady = apiConfigured && ipnConfigured && serviceStatus !== "error";
      console.log("[Payment Service Status] Service ready status:", isReady ? "READY" : "NOT READY");
      console.log("[Payment Service Status] ========= END PAYMENT STATUS CHECK =========");
      res.json({
        apiConfigured,
        ipnConfigured,
        serviceStatus,
        error: errorMessage,
        ready: isReady,
        minAmount
      });
    } catch (error) {
      console.error("[Payment Service Status] Unexpected error:", error);
      res.status(500).json({
        error: "Failed to check payment service status",
        apiConfigured: isNOWPaymentsConfigured2(),
        ipnConfigured: isIPNSecretConfigured2(),
        serviceStatus: "error",
        ready: false
      });
    }
  });
  app2.post("/api/public/payments/test-invoice", async (req, res) => {
    try {
      const schema = z3.object({
        amount: z3.number().positive(),
        currency: z3.string().optional(),
        useFallback: z3.boolean().optional()
      });
      const result = schema.safeParse(req.body);
      if (!result.success) {
        return res.status(400).json({ error: "Invalid request parameters", details: result.error });
      }
      const { amount, useFallback = false } = result.data;
      const currency = "USDT";
      const successUrl = `${config.urls.app}/wallet?payment=success`;
      const cancelUrl = `${config.urls.app}/wallet?payment=cancelled`;
      const callbackUrl = `${config.urls.api}/api/ipn/nowpayments`;
      if (useFallback || !nowPaymentsService.isConfigured()) {
        console.log(`Creating fallback test payment for amount: ${amount} ${currency}`);
        const testTxId = `TEST-${Date.now()}`;
        const testPaymentUrl = `${config.urls.app}/dev-payment.html?invoice=${testTxId}&amount=${amount}&currency=${currency}&success=${encodeURIComponent(successUrl)}&cancel=${encodeURIComponent(cancelUrl)}`;
        return res.json({
          success: true,
          invoice: {
            id: testTxId,
            status: "test_mode",
            invoiceUrl: testPaymentUrl
          },
          message: "Using test payment system"
        });
      }
      try {
        console.log(`Creating NOWPayments payment for test user, amount: ${amount} ${currency}`);
        const payment = await nowPaymentsService.createPayment(
          0,
          // Use 0 as user ID for test payments
          amount,
          `ChickFarms test payment - ${amount} ${currency}`
        );
        console.log(`Created test payment with ID ${payment.payment_id}, payment URL: ${payment.payment_url}`);
        return res.json({
          success: true,
          invoice: {
            id: payment.payment_id,
            status: "created",
            invoiceUrl: payment.payment_url
          }
        });
      } catch (apiError) {
        console.error("Error creating NOWPayments payment:", apiError);
        console.log("Falling back to test payment due to API error");
        const testTxId = `FALLBACK-${Date.now()}`;
        const testPaymentUrl = `${config.urls.app}/dev-payment.html?invoice=${testTxId}&amount=${amount}&currency=${currency}&success=${encodeURIComponent(successUrl)}&cancel=${encodeURIComponent(cancelUrl)}`;
        return res.json({
          success: true,
          invoice: {
            id: testTxId,
            status: "fallback_mode",
            invoiceUrl: testPaymentUrl
          },
          message: "Using fallback test payment system due to API error"
        });
      }
    } catch (error) {
      console.error("Unexpected error in test payment endpoint:", error);
      res.status(500).json({ error: "Failed to create test payment invoice" });
    }
  });
  app2.get("/api/dev/simulate-payment/:invoiceId", async (req, res) => {
    try {
      if (config.env.isProduction) {
        return res.status(403).json({
          error: "Forbidden",
          message: "This endpoint is only available in development mode"
        });
      }
      const { invoiceId } = req.params;
      if (!invoiceId) {
        return res.status(400).json({ error: "Missing invoice ID" });
      }
      console.log(`[DEV] Simulating successful payment for invoice: ${invoiceId}`);
      const isTestPayment = invoiceId.startsWith("TEST-") || invoiceId.startsWith("DEV-");
      if (isTestPayment) {
        console.log(`[DEV] Test payment completed successfully: ${invoiceId}`);
        return res.json({
          success: true,
          message: "Test payment simulated successfully",
          invoiceId
        });
      }
      const transaction = await storage.getTransactionByTransactionId(invoiceId);
      if (!transaction) {
        return res.status(404).json({ error: "Transaction not found" });
      }
      console.log(`[DEV] Found transaction ID ${transaction.id} for user ${transaction.userId}`);
      await storage.updateTransactionStatus(invoiceId, "completed");
      const user = await storage.getUser(transaction.userId);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }
      console.log(`[DEV] Updating balance for user ${user.id}, adding ${transaction.amount}`);
      await storage.updateUserBalance(user.id, parseFloat(transaction.amount));
      res.json({
        success: true,
        message: "Payment simulated successfully",
        invoiceId,
        userId: user.id,
        amount: transaction.amount
      });
    } catch (error) {
      console.error("Error simulating payment:", error);
      res.status(500).json({ error: "Failed to simulate payment" });
    }
  });
  app2.get("/api/payments/verify-config", isAuthenticated, async (req, res) => {
    try {
      const apiKeyConfigured = isNOWPaymentsConfigured2();
      const ipnSecretConfigured = isIPNSecretConfigured2();
      let apiStatus = "unknown";
      let minAmount = null;
      if (apiKeyConfigured) {
        try {
          const status = await nowPaymentsService.getStatus();
          apiStatus = status.status || "unknown";
          try {
            minAmount = await nowPaymentsService.getMinimumPaymentAmount("usdttrc20");
          } catch (minAmountError) {
            console.error("Failed to get minimum amount:", minAmountError);
          }
        } catch (statusError) {
          apiStatus = "error";
          console.error("Failed to get NOWPayments status:", statusError);
        }
      }
      res.json({
        apiKeyConfigured,
        ipnSecretConfigured,
        apiStatus,
        minAmount,
        config: {
          callbackUrl: `${config.urls.api}/api/payments/callback`,
          successUrl: `${config.urls.app}/wallet?payment=success`,
          cancelUrl: `${config.urls.app}/wallet?payment=cancelled`
        }
      });
    } catch (error) {
      console.error("Error verifying NOWPayments config:", error);
      res.status(500).json({ error: "Failed to verify payment configuration" });
    }
  });
  app2.post("/api/payments/create-invoice", isAuthenticated, async (req, res) => {
    try {
      const schema = z3.object({
        amount: z3.number().positive()
      });
      const result = schema.safeParse(req.body);
      if (!result.success) {
        return res.status(400).json({ error: "Invalid request parameters", details: result.error });
      }
      const { amount } = result.data;
      const currency = "USDT";
      const user = req.user;
      console.log(`Creating NOWPayments payment for user ${user.id}, amount: ${amount} ${currency}`);
      const payment = await nowPaymentsService.createPayment(
        user.id,
        amount,
        `ChickFarms deposit - User ID: ${user.id}`,
        currency
      );
      await storage.createTransaction(
        user.id,
        "recharge",
        amount,
        payment.payment_id,
        // Use the payment ID as the transaction ID
        void 0,
        JSON.stringify({ method: "nowpayments", paymentId: payment.payment_id })
      );
      console.log(`Created payment with ID ${payment.payment_id}, payment URL: ${payment.payment_url}`);
      res.json({
        success: true,
        invoiceId: payment.payment_id,
        invoiceUrl: payment.payment_url
      });
    } catch (error) {
      console.error("Error creating NOWPayments payment:", error);
      res.status(500).json({ error: "Failed to create payment" });
    }
  });
  app2.get("/api/payments/invoice-status/:invoiceId", isAuthenticated, async (req, res) => {
    try {
      const { invoiceId } = req.params;
      const user = req.user;
      const transaction = await storage.getTransactionByTransactionId(invoiceId);
      if (!transaction) {
        return res.status(404).json({ error: "Transaction not found" });
      }
      if (transaction.userId !== user.id && !user.isAdmin) {
        return res.status(403).json({ error: "Not authorized to view this transaction" });
      }
      res.json({
        success: true,
        status: transaction.status,
        amount: transaction.amount,
        transactionId: transaction.transactionId,
        createdAt: transaction.createdAt
      });
    } catch (error) {
      console.error("Error checking invoice status:", error);
      res.status(500).json({ error: "Failed to check invoice status" });
    }
  });
  app2.get("/api/payments/status/:paymentId", isAuthenticated, async (req, res) => {
    try {
      const { paymentId } = req.params;
      const user = req.user;
      if (!paymentId) {
        return res.status(400).json({ error: "Missing payment ID" });
      }
      console.log(`[Payment Status] Checking status for payment ID ${paymentId}`);
      const transaction = await storage.getTransactionByTransactionId(paymentId);
      if (!transaction) {
        console.error(`[Payment Status] Transaction not found for payment ID ${paymentId}`);
        return res.status(404).json({ error: "Transaction not found" });
      }
      if (transaction.userId !== user.id && !user.isAdmin) {
        return res.status(403).json({ error: "Not authorized to check this payment" });
      }
      console.log(`[Payment Status] Found transaction in DB with status: ${transaction.status}`);
      if (transaction.status === "completed") {
        return res.json({
          status: "completed",
          amount: transaction.amount,
          createdAt: transaction.createdAt
        });
      }
      if (!paymentId.startsWith("M") && isNOWPaymentsConfigured2()) {
        try {
          const paymentStatus = await nowPaymentsService.getPaymentStatus(paymentId);
          const mappedStatus = nowPaymentsService.mapPaymentStatusToTransactionStatus(paymentStatus.payment_status);
          console.log(`[Payment Status] NOWPayments reports status: ${paymentStatus.payment_status} (mapped to ${mappedStatus})`);
          if (mappedStatus === "completed" && transaction.status !== "completed") {
            console.log(`[Payment Status] Updating transaction ${paymentId} to completed`);
            await storage.updateTransactionStatus(paymentId, "completed");
            await storage.updateUserBalance(transaction.userId, parseFloat(transaction.amount));
            const user2 = await storage.getUser(transaction.userId);
            if (user2 && user2.referredBy) {
              const referrer = await storage.getUserByReferralCode(user2.referredBy);
              if (referrer) {
                console.log(`[Payment Status] Processing referral commission for payment ${paymentId}`);
                const level1Amount = parseFloat(transaction.amount) * 0.1;
                await storage.updateUserBalance(referrer.id, level1Amount);
                await storage.updateUserReferralEarnings(referrer.id, level1Amount);
                await storage.updateUserTeamEarnings(referrer.id, level1Amount);
                await storage.createReferralEarning({
                  userId: referrer.id,
                  referredUserId: transaction.userId,
                  level: 1,
                  amount: level1Amount.toFixed(2),
                  claimed: false
                });
              }
            }
          }
          return res.json({
            status: mappedStatus,
            nowPaymentsStatus: paymentStatus.payment_status,
            amount: transaction.amount,
            createdAt: transaction.createdAt,
            lastChecked: (/* @__PURE__ */ new Date()).toISOString()
          });
        } catch (apiError) {
          console.error(`[Payment Status] Error checking status with NOWPayments API:`, apiError);
        }
      }
      return res.json({
        status: transaction.status,
        amount: transaction.amount,
        createdAt: transaction.createdAt
      });
    } catch (error) {
      console.error("Error checking payment status:", error);
      res.status(500).json({ error: "Failed to check payment status" });
    }
  });
  app2.get("/api/payments/currencies", async (req, res) => {
    try {
      const currencies = await nowPaymentsService.getAvailableCurrencies();
      res.json(currencies);
    } catch (error) {
      console.error("Error retrieving available currencies:", error);
      res.status(500).json({ error: "Failed to retrieve available currencies" });
    }
  });
  app2.get("/api/payments/min-amount", async (req, res) => {
    try {
      let currency = req.query.currency || "USDT";
      if (currency.toUpperCase() === "USDT") {
        currency = "usdttrc20";
      }
      const minAmount = await nowPaymentsService.getMinimumPaymentAmount(currency);
      res.json({ minAmount, currency });
    } catch (error) {
      console.error("Error retrieving minimum amount:", error);
      res.status(500).json({ error: "Failed to retrieve minimum payment amount" });
    }
  });
  app2.post("/api/ipn/nowpayments", async (req, res) => {
    try {
      console.log("[NOWPayments Callback] Received payment callback:", JSON.stringify(req.body));
      const ipnData = req.body;
      const ipnSecretKey = config.nowpayments.ipnSecretKey;
      const isIpnConfigured = isIPNSecretConfigured2();
      console.log("[NOWPayments Callback] IPN Secret configured:", isIpnConfigured ? "YES" : "NO");
      if (ipnSecretKey && isIpnConfigured) {
        const ipnSignature = req.headers["x-nowpayments-sig"];
        if (!ipnSignature) {
          console.error("[NOWPayments Callback] Missing signature in IPN headers");
          console.error("[NOWPayments Callback] Headers received:", JSON.stringify(req.headers));
          return res.status(400).json({ error: "Missing signature" });
        }
        const hmac = crypto.createHmac("sha512", ipnSecretKey);
        const rawBody = typeof ipnData === "string" ? ipnData : JSON.stringify(ipnData);
        const computedSignature = hmac.update(rawBody).digest("hex");
        console.log("[NOWPayments Callback] Signature verification:");
        console.log("Received signature:", ipnSignature);
        console.log("Computed signature:", computedSignature);
        if (computedSignature !== ipnSignature) {
          console.error("[NOWPayments Callback] Invalid IPN signature");
          return res.status(403).json({ error: "Invalid signature" });
        }
        console.log("[NOWPayments Callback] IPN signature verified successfully");
      } else {
        console.warn("[NOWPayments Callback] IPN secret not configured or invalid, skipping signature verification");
      }
      if (!ipnData.payment_id) {
        console.error("[NOWPayments Callback] Missing payment_id in IPN data");
        return res.status(400).json({ error: "Missing payment_id" });
      }
      const paymentId = ipnData.payment_id;
      const paymentStatus = ipnData.payment_status;
      console.log(`[NOWPayments Callback] Processing payment ${paymentId} with status ${paymentStatus}`);
      const transaction = await storage.getTransactionByTransactionId(paymentId);
      if (!transaction) {
        console.error(`[NOWPayments Callback] Transaction not found for payment ID ${paymentId}`);
        return res.status(404).json({ error: "Transaction not found" });
      }
      console.log(`[NOWPayments Callback] Found transaction ID ${transaction.id} for user ${transaction.userId}`);
      const newStatus = nowPaymentsService.mapPaymentStatusToTransactionStatus(paymentStatus);
      if (newStatus === "completed" && transaction.status !== "completed") {
        console.log(`[NOWPayments Callback] Updating transaction ${transaction.id} to status ${newStatus}`);
        await storage.updateTransactionStatus(paymentId, newStatus);
        const user = await storage.getUser(transaction.userId);
        if (!user) {
          console.error(`[NOWPayments Callback] User ${transaction.userId} not found`);
          return res.status(404).json({ error: "User not found" });
        }
        console.log(`[NOWPayments Callback] Updating balance for user ${user.id}, adding ${transaction.amount}`);
        await storage.updateUserBalance(user.id, parseFloat(transaction.amount));
        const userTransactions = await storage.getTransactionsByUserId(user.id);
        const completedDeposits = userTransactions.filter(
          (t) => t.type === "recharge" && t.status === "completed" && t.id !== transaction.id
          // Exclude current transaction
        );
        const isFirstDeposit = completedDeposits.length === 0;
        if (isFirstDeposit) {
          const bonusAmount = parseFloat(transaction.amount) * 0.1;
          console.log(`[NOWPayments Callback] Applying first deposit bonus: ${bonusAmount} for user ${user.id}`);
          await storage.createTransaction(
            user.id,
            "bonus",
            bonusAmount,
            `bonus-${transaction.transactionId}`,
            void 0,
            JSON.stringify({ reason: "First deposit bonus" })
          );
          await storage.updateUserBalance(user.id, bonusAmount);
        }
        if (user.referredBy) {
          try {
            const referrer = await storage.getUserByReferralCode(user.referredBy);
            if (referrer) {
              console.log(`[NOWPayments Callback] Processing referral commission for referrer ${referrer.id}`);
              const level1Amount = parseFloat(transaction.amount) * 0.1;
              await storage.updateUserBalance(referrer.id, level1Amount);
              await storage.updateUserReferralEarnings(referrer.id, level1Amount);
              await storage.updateUserTeamEarnings(referrer.id, level1Amount);
              await storage.createReferralEarning({
                userId: referrer.id,
                referredUserId: user.id,
                level: 1,
                amount: level1Amount.toFixed(2),
                claimed: false
              });
              let currentReferrer = referrer;
              for (let level = 2; level <= 6; level++) {
                if (!currentReferrer.referredBy) break;
                const nextReferrer = await storage.getUserByReferralCode(currentReferrer.referredBy);
                if (!nextReferrer) break;
                let commissionRate = 0;
                switch (level) {
                  case 2:
                    commissionRate = referralCommissionRates.level2;
                    break;
                  // 6%
                  case 3:
                    commissionRate = referralCommissionRates.level3;
                    break;
                  // 4%
                  case 4:
                    commissionRate = referralCommissionRates.level4;
                    break;
                  // 3%
                  case 5:
                    commissionRate = referralCommissionRates.level5;
                    break;
                  // 2%
                  case 6:
                    commissionRate = referralCommissionRates.level6;
                    break;
                  // 1%
                  default:
                    commissionRate = 0;
                }
                const commissionAmount = parseFloat(transaction.amount) * commissionRate;
                console.log(`[NOWPayments Callback] Processing level ${level} commission: ${commissionAmount} for user ${nextReferrer.id}`);
                await storage.updateUserBalance(nextReferrer.id, commissionAmount);
                await storage.updateUserReferralEarnings(nextReferrer.id, commissionAmount);
                await storage.updateUserTeamEarnings(nextReferrer.id, commissionAmount);
                await storage.createReferralEarning({
                  userId: nextReferrer.id,
                  referredUserId: user.id,
                  level,
                  amount: commissionAmount.toFixed(2),
                  claimed: false
                });
                currentReferrer = nextReferrer;
              }
            }
          } catch (referralError) {
            console.error("[NOWPayments Callback] Error processing referral commissions:", referralError);
          }
        }
      } else {
        console.log(`[NOWPayments Callback] Transaction status unchanged or not completed: ${paymentStatus}`);
      }
      res.status(200).json({ status: "success" });
    } catch (error) {
      console.error("[NOWPayments Callback] Error processing payment callback:", error);
      res.status(200).json({ status: "error", message: "Error processing payment callback" });
    }
  });
  app2.get("/api/public/payments/:paymentId/status", async (req, res) => {
    try {
      const paymentId = req.params.paymentId;
      const transaction = await storage.getTransactionByTransactionId(paymentId);
      if (!transaction) {
        return res.status(404).json({ error: "Transaction not found" });
      }
      const createdAt = transaction.createdAt ? transaction.createdAt instanceof Date ? transaction.createdAt.toISOString() : typeof transaction.createdAt === "string" ? transaction.createdAt : new Date(transaction.createdAt).toISOString() : (/* @__PURE__ */ new Date()).toISOString();
      let paymentStatus = {
        payment_id: paymentId,
        payment_status: transaction.status === "pending" ? "waiting" : transaction.status,
        pay_address: "",
        price_amount: parseFloat(transaction.amount),
        price_currency: "USDT",
        pay_amount: parseFloat(transaction.amount),
        pay_currency: "USDT",
        created_at: createdAt,
        // Always a string in ISO format
        actually_paid: null,
        actually_paid_at: null,
        updated_at: null
      };
      try {
        if (paymentId.startsWith("M")) {
          if (typeof transaction.bankDetails === "string") {
            try {
              const details = JSON.parse(transaction.bankDetails);
              if (details.paymentAddress) {
                paymentStatus.pay_address = details.paymentAddress;
              }
            } catch (e) {
              console.error("[Payment Status] Error parsing bankDetails:", e);
            }
          }
          console.log(`[Payment Status] Manual payment ${paymentId} status: ${paymentStatus.payment_status}`);
        } else {
          try {
            const apiPaymentStatus = await nowPaymentsService.getPaymentStatus(paymentId);
            paymentStatus = {
              payment_id: apiPaymentStatus.payment_id,
              payment_status: apiPaymentStatus.payment_status,
              pay_address: apiPaymentStatus.pay_address || "",
              price_amount: apiPaymentStatus.price_amount,
              price_currency: apiPaymentStatus.price_currency,
              pay_amount: apiPaymentStatus.pay_amount,
              pay_currency: apiPaymentStatus.pay_currency,
              created_at: apiPaymentStatus.created_at,
              actually_paid: null,
              // Keep as null for type compatibility
              actually_paid_at: null,
              // Keep as null for type compatibility
              updated_at: null
              // Keep as null for type compatibility
            };
          } catch (apiError) {
            console.error(`[NOWPayments] API error getting payment status:`, apiError);
          }
        }
        res.json({
          transaction: {
            id: transaction.id,
            status: transaction.status,
            amount: transaction.amount,
            createdAt: transaction.createdAt
          },
          payment: {
            paymentId: paymentStatus.payment_id,
            status: paymentStatus.payment_status,
            payAddress: paymentStatus.pay_address,
            amount: paymentStatus.pay_amount,
            currency: paymentStatus.pay_currency,
            actuallyPaid: paymentStatus.actually_paid,
            actuallyPaidAt: paymentStatus.actually_paid_at,
            updatedAt: paymentStatus.updated_at
          }
        });
      } catch (error) {
        console.error(`[NOWPayments] Error checking public payment status:`, error);
        res.status(500).json({ error: "Failed to check payment status" });
      }
    } catch (error) {
      console.error(`[NOWPayments] Error in public payment status:`, error);
      res.status(500).json({ error: "Failed to process payment status" });
    }
  });
  app2.get("/api/payments/:paymentId/status", isAuthenticated, async (req, res) => {
    try {
      const paymentId = req.params.paymentId;
      const transaction = await storage.getTransactionByTransactionId(paymentId);
      if (!transaction) {
        return res.status(404).json({ error: "Transaction not found" });
      }
      if (transaction.userId !== req.user.id) {
        return res.status(403).json({ error: "Unauthorized access to transaction" });
      }
      const createdAt = transaction.createdAt ? transaction.createdAt instanceof Date ? transaction.createdAt.toISOString() : typeof transaction.createdAt === "string" ? transaction.createdAt : new Date(transaction.createdAt).toISOString() : (/* @__PURE__ */ new Date()).toISOString();
      let paymentStatus = {
        payment_id: paymentId,
        payment_status: transaction.status === "pending" ? "waiting" : transaction.status,
        pay_address: "",
        price_amount: parseFloat(transaction.amount),
        price_currency: "USDT",
        pay_amount: parseFloat(transaction.amount),
        pay_currency: "USDT",
        created_at: createdAt,
        // Always a string in ISO format
        actually_paid: null,
        actually_paid_at: null,
        updated_at: null
      };
      try {
        if (paymentId.startsWith("M")) {
          if (typeof transaction.bankDetails === "string") {
            try {
              const details = JSON.parse(transaction.bankDetails);
              if (details.paymentAddress) {
                paymentStatus.pay_address = details.paymentAddress;
              }
            } catch (e) {
              console.error("[Payment Status] Error parsing bankDetails:", e);
            }
          }
          console.log(`[Payment Status] Manual payment ${paymentId} status: ${paymentStatus.payment_status}`);
        } else {
          try {
            const apiPaymentStatus = await nowPaymentsService.getPaymentStatus(paymentId);
            if (apiPaymentStatus) {
              paymentStatus.payment_id = apiPaymentStatus.payment_id;
              paymentStatus.payment_status = apiPaymentStatus.payment_status;
              paymentStatus.pay_address = apiPaymentStatus.pay_address;
              paymentStatus.price_amount = apiPaymentStatus.price_amount;
              paymentStatus.price_currency = apiPaymentStatus.price_currency;
              paymentStatus.pay_amount = apiPaymentStatus.pay_amount;
              paymentStatus.pay_currency = apiPaymentStatus.pay_currency;
              if (apiPaymentStatus.created_at) {
                paymentStatus.created_at = transaction.createdAt instanceof Date ? transaction.createdAt.toISOString() : typeof transaction.createdAt === "string" ? transaction.createdAt : new Date(transaction.createdAt).toISOString();
              }
              paymentStatus.actually_paid = null;
              paymentStatus.actually_paid_at = null;
              paymentStatus.updated_at = null;
            }
          } catch (apiError) {
            console.error(`[NOWPayments] API error getting payment status:`, apiError);
          }
        }
        if (paymentStatus.payment_status === "finished" && transaction.status === "pending") {
          console.log(`[NOWPayments] Payment ${paymentId} is completed, updating transaction status`);
          await storage.updateTransactionStatus(paymentId, "completed");
          await storage.updateUserBalance(req.user.id, parseFloat(transaction.amount));
          const user = await storage.getUser(req.user.id);
          if (user && user.referredBy) {
            try {
              const referrer = await storage.getUserByReferralCode(user.referredBy);
              if (referrer) {
                console.log(`[NOWPayments] Processing referral commission for payment ${paymentId}`);
                const level1Amount = parseFloat(transaction.amount) * 0.1;
                await storage.updateUserBalance(referrer.id, level1Amount);
                await storage.updateUserReferralEarnings(referrer.id, level1Amount);
                await storage.updateUserTeamEarnings(referrer.id, level1Amount);
                await storage.createReferralEarning({
                  userId: referrer.id,
                  referredUserId: req.user.id,
                  level: 1,
                  amount: level1Amount.toFixed(2),
                  claimed: false
                });
              }
            } catch (referralError) {
              console.error(`[NOWPayments] Error processing referral for payment ${paymentId}:`, referralError);
            }
          }
        }
      } catch (innerError) {
        console.error(`[NOWPayments] Inner error checking payment status:`, innerError);
      }
      res.json({
        transaction: {
          id: transaction.id,
          status: transaction.status,
          amount: transaction.amount,
          createdAt: transaction.createdAt
        },
        payment: {
          paymentId: paymentStatus.payment_id,
          status: paymentStatus.payment_status,
          payAddress: paymentStatus.pay_address,
          amount: paymentStatus.pay_amount,
          currency: paymentStatus.pay_currency,
          actuallyPaid: paymentStatus.actually_paid,
          actuallyPaidAt: paymentStatus.actually_paid_at,
          updatedAt: paymentStatus.updated_at
        }
      });
    } catch (error) {
      console.error(`[NOWPayments] Error checking payment status:`, error);
      res.status(500).json({ error: "Failed to check payment status" });
    }
  });
  app2.get("/api/admin/transactions", async (req, res) => {
    try {
      console.log("[Admin Route] Getting transactions");
      const transactions2 = await storage.getTransactions();
      res.json(transactions2);
    } catch (err) {
      console.error("[Admin Route] Error getting transactions:", err);
      res.status(500).json({ error: "Failed to fetch transactions" });
    }
  });
  app2.get("/api/admin/withdrawals", async (req, res) => {
    const transactions2 = await storage.getTransactions();
    const withdrawals = transactions2.filter((transaction) => transaction.type === "withdrawal");
    res.json(withdrawals);
  });
  app2.get("/api/admin/stats", async (req, res) => {
    const transactions2 = await storage.getTransactions();
    const users2 = await storage.getUser(1);
    const today = /* @__PURE__ */ new Date();
    today.setHours(0, 0, 0, 0);
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);
    const yesterday = new Date(today);
    yesterday.setDate(yesterday.getDate() - 1);
    const todayDeposits = transactions2.filter((t) => t.type === "recharge" && t.status === "completed" && new Date(t.createdAt) >= today && new Date(t.createdAt) < tomorrow).reduce((sum, t) => sum + parseFloat(t.amount), 0);
    const totalDeposits = transactions2.filter((t) => t.type === "recharge" && t.status === "completed").reduce((sum, t) => sum + parseFloat(t.amount), 0);
    const todayWithdrawals = transactions2.filter((t) => t.type === "withdrawal" && t.status === "completed" && new Date(t.createdAt) >= today && new Date(t.createdAt) < tomorrow).reduce((sum, t) => sum + parseFloat(t.amount), 0);
    const totalWithdrawals = transactions2.filter((t) => t.type === "withdrawal" && t.status === "completed").reduce((sum, t) => sum + parseFloat(t.amount), 0);
    const pendingWithdrawals = transactions2.filter((t) => t.type === "withdrawal" && t.status === "pending").length;
    const userCount = users2?.id || 0;
    const stats = {
      todayLogins: 0,
      // This should be tracked properly in a real system
      yesterdayLogins: 0,
      // This should be tracked properly in a real system
      totalUsers: userCount,
      todayDeposits,
      totalDeposits,
      todayWithdrawals,
      totalWithdrawals,
      pendingWithdrawals
    };
    res.json(stats);
  });
  app2.get("/api/admin/prices", async (req, res) => {
    try {
      const prices2 = await storage.getPrices();
      const gamePrices = {
        waterBucketPrice: parseFloat(prices2.find((p) => p.itemType === "water_bucket")?.price || "0.5"),
        wheatBagPrice: parseFloat(prices2.find((p) => p.itemType === "wheat_bag")?.price || "0.5"),
        eggPrice: parseFloat(prices2.find((p) => p.itemType === "egg")?.price || "0.1"),
        babyChickenPrice: parseFloat(prices2.find((p) => p.itemType === "baby_chicken")?.price || "90"),
        regularChickenPrice: parseFloat(prices2.find((p) => p.itemType === "regular_chicken")?.price || "150"),
        goldenChickenPrice: parseFloat(prices2.find((p) => p.itemType === "golden_chicken")?.price || "400"),
        // Mystery box prices
        mysteryBoxPrice: parseFloat(prices2.find((p) => p.itemType === "mystery_box")?.price || "50"),
        basicMysteryBoxPrice: parseFloat(prices2.find((p) => p.itemType === "basic_mystery_box")?.price || "5"),
        standardMysteryBoxPrice: parseFloat(prices2.find((p) => p.itemType === "standard_mystery_box")?.price || "10"),
        advancedMysteryBoxPrice: parseFloat(prices2.find((p) => p.itemType === "advanced_mystery_box")?.price || "20"),
        legendaryMysteryBoxPrice: parseFloat(prices2.find((p) => p.itemType === "legendary_mystery_box")?.price || "50"),
        withdrawalTaxPercentage: 5
        // Default value, you might want to get this from settings table
      };
      res.json(gamePrices);
    } catch (err) {
      console.error("Error fetching game prices:", err);
      res.status(500).json({ error: "Failed to fetch game prices" });
    }
  });
  app2.post("/api/admin/prices/update", async (req, res) => {
    try {
      console.log("Received price updates:", req.body.prices);
      if (!Array.isArray(req.body.prices)) {
        console.error("Invalid price updates format:", req.body);
        return res.status(400).json({ error: "Invalid price updates format" });
      }
      for (const priceUpdate of req.body.prices) {
        const schema = z3.object({
          itemType: z3.string(),
          price: z3.number().positive()
        });
        const result = schema.safeParse(priceUpdate);
        if (!result.success) {
          console.error("Invalid price update:", priceUpdate, result.error);
          continue;
        }
        console.log("Updating price:", result.data);
        await storage.updatePrice(result.data.itemType, result.data.price);
      }
      if (typeof req.body.withdrawalTaxPercentage === "number") {
        console.log("Updating withdrawal tax:", req.body.withdrawalTaxPercentage);
        await storage.updateWithdrawalTax(req.body.withdrawalTaxPercentage);
      }
      const updatedPrices = await storage.getPrices();
      console.log("Updated prices:", updatedPrices);
      res.json({ success: true, prices: updatedPrices });
    } catch (err) {
      console.error("Error updating prices:", err);
      res.status(500).json({ error: "Failed to update prices" });
    }
  });
  app2.get("/api/prices", async (req, res) => {
    try {
      const prices2 = await storage.getPrices();
      console.log("Fetched prices:", prices2);
      res.json(prices2);
    } catch (err) {
      console.error("Error fetching prices:", err);
      res.status(500).json({ error: "Failed to fetch prices" });
    }
  });
  app2.get("/api/spin/status", isAuthenticated, async (req, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }
      const now = /* @__PURE__ */ new Date();
      const lastSpinTime = user.lastSpinAt ? new Date(user.lastSpinAt) : null;
      let canSpinDaily = true;
      let timeUntilNextSpin = 0;
      if (lastSpinTime) {
        const timeElapsed = now.getTime() - lastSpinTime.getTime();
        const oneDayMs = 24 * 60 * 60 * 1e3;
        if (timeElapsed < oneDayMs) {
          canSpinDaily = false;
          timeUntilNextSpin = oneDayMs - timeElapsed;
        }
      }
      res.json({
        canSpinDaily,
        timeUntilNextSpin,
        extraSpinsAvailable: user.extraSpinsAvailable || 0
      });
    } catch (err) {
      console.error("Error checking spin status:", err);
      res.status(500).json({ error: "Failed to check spin status" });
    }
  });
  app2.post("/api/spin/claim", isAuthenticated, async (req, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }
      const now = /* @__PURE__ */ new Date();
      const lastSpinTime = user.lastSpinAt ? new Date(user.lastSpinAt) : null;
      let canSpin = true;
      if (req.body.spinType === "daily") {
        if (lastSpinTime) {
          const timeElapsed = now.getTime() - lastSpinTime.getTime();
          const oneDayMs = 24 * 60 * 60 * 1e3;
          if (timeElapsed < oneDayMs) {
            canSpin = false;
          }
        }
        if (!canSpin) {
          return res.status(400).json({ error: "Daily spin not available yet" });
        }
        await storage.updateUserLastSpin(userId);
      } else if (req.body.spinType === "extra") {
        if (!user.extraSpinsAvailable || user.extraSpinsAvailable <= 0) {
          return res.status(400).json({ error: "No extra spins available" });
        }
        await storage.updateExtraSpinsAvailable(userId, user.extraSpinsAvailable - 1);
      } else if (req.body.spinType === "super") {
        return res.status(400).json({ error: "Super jackpot spin not available" });
      } else {
        return res.status(400).json({ error: "Invalid spin type" });
      }
      const rewards = req.body.spinType === "super" ? [
        { type: "eggs", amount: 50 },
        { type: "eggs", amount: 100 },
        { type: "eggs", amount: 200 },
        { type: "wheat", amount: 25 },
        { type: "water", amount: 25 },
        { type: "usdt", amount: 5 },
        { type: "usdt", amount: 10 },
        { type: "usdt", amount: 50 },
        { type: "chicken", amount: 1, chickenType: "regular" },
        { type: "chicken", amount: 1, chickenType: "golden" }
      ] : [
        { type: "eggs", amount: 5 },
        { type: "eggs", amount: 10 },
        { type: "eggs", amount: 15 },
        { type: "wheat", amount: 5 },
        { type: "water", amount: 5 },
        { type: "extra_spin", amount: 1 },
        { type: "usdt", amount: 0.5 },
        { type: "usdt", amount: 1 }
      ];
      const reward = rewards[Math.floor(Math.random() * rewards.length)];
      switch (reward.type) {
        case "eggs":
          await storage.updateResourceEggs(userId, reward.amount);
          break;
        case "wheat":
          await storage.updateResourceWheat(userId, reward.amount);
          break;
        case "water":
          await storage.updateResourceWater(userId, reward.amount);
          break;
        case "extra_spin":
          await storage.updateExtraSpinsAvailable(userId, (user.extraSpinsAvailable || 0) + reward.amount);
          break;
        case "usdt":
          await storage.updateUserBalance(userId, reward.amount);
          break;
        case "chicken":
          const chickenType = reward.chickenType || "baby";
          await storage.createChicken(userId, chickenType);
          break;
      }
      res.json({
        success: true,
        reward
      });
    } catch (err) {
      console.error("Error claiming spin reward:", err);
      res.status(500).json({ error: "Failed to claim spin reward" });
    }
  });
  function calculateChickenExpiryDate(chickenType) {
    const now = /* @__PURE__ */ new Date();
    const expiresAt = new Date(now);
    switch (chickenType) {
      case "baby":
        expiresAt.setDate(now.getDate() + 15);
        break;
      case "regular":
        expiresAt.setDate(now.getDate() + 30);
        break;
      case "golden":
        expiresAt.setDate(now.getDate() + 60);
        break;
      default:
        expiresAt.setDate(now.getDate() + 15);
    }
    return expiresAt;
  }
  app2.get("/api/spin/rewards", isAuthenticated, async (req, res) => {
    try {
      let dailyRewards2 = await storage.getSpinRewardsByType("daily");
      let superRewards = await storage.getSpinRewardsByType("super");
      if (!dailyRewards2 || dailyRewards2.length === 0) {
        console.log("[API] No daily rewards found in database, using defaults from schema");
        dailyRewards2 = dailySpinRewards.map((reward) => ({
          id: 0,
          spinType: "daily",
          rewardType: reward.reward.type,
          amount: reward.reward.amount.toString(),
          chickenType: reward.reward.chickenType || null,
          probability: reward.probability.toString(),
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }));
      }
      if (!superRewards || superRewards.length === 0) {
        console.log("[API] No super jackpot rewards found in database, using defaults from schema");
        superRewards = superJackpotRewards.map((reward) => ({
          id: 0,
          spinType: "super",
          rewardType: reward.reward.type,
          amount: reward.reward.amount.toString(),
          chickenType: reward.reward.chickenType || null,
          probability: reward.probability.toString(),
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }));
      }
      const formattedDailyRewards = dailyRewards2.map((r) => ({
        reward: {
          type: r.rewardType,
          amount: parseFloat(r.amount.toString()),
          ...r.chickenType && { chickenType: r.chickenType }
        },
        probability: parseFloat(r.probability.toString()),
        id: r.id
      }));
      const formattedSuperRewards = superRewards.map((r) => ({
        reward: {
          type: r.rewardType,
          amount: parseFloat(r.amount.toString()),
          ...r.chickenType && { chickenType: r.chickenType }
        },
        probability: parseFloat(r.probability.toString()),
        id: r.id
      }));
      res.json({
        daily: formattedDailyRewards,
        super: formattedSuperRewards
      });
    } catch (err) {
      console.error("Error fetching spin rewards:", err);
      res.status(500).json({ error: "Failed to fetch spin rewards" });
    }
  });
  app2.post("/api/admin/spin/rewards/update", isAdmin, async (req, res) => {
    try {
      const { rewards, spinType } = req.body;
      if (!rewards || !Array.isArray(rewards) || !spinType) {
        return res.status(400).json({ error: "Invalid rewards format" });
      }
      if (spinType !== "daily" && spinType !== "super") {
        return res.status(400).json({ error: "Invalid spin type: must be 'daily' or 'super'" });
      }
      console.log(`[Admin] Updating ${spinType} spin rewards:`, rewards);
      const existingRewards = await storage.getSpinRewardsByType(spinType);
      const existingIds = new Set(existingRewards.map((r) => r.id));
      const updatedIds = new Set(rewards.filter((r) => r.id).map((r) => r.id));
      const updatedRewards = [];
      for (const reward of rewards) {
        const spinReward = {
          spinType,
          rewardType: reward.reward.type,
          amount: reward.reward.amount.toString(),
          chickenType: reward.reward.chickenType || null,
          probability: reward.probability.toString()
        };
        if (reward.id && existingIds.has(reward.id)) {
          console.log(`[Admin] Updating existing reward ID: ${reward.id}`);
          const updated = await storage.updateSpinReward(reward.id, spinReward);
          updatedRewards.push(updated);
        } else {
          console.log(`[Admin] Creating new reward`);
          const created = await storage.createSpinReward(spinReward);
          updatedRewards.push(created);
        }
      }
      Array.from(existingIds).forEach(async (existingId) => {
        if (!updatedIds.has(existingId)) {
          console.log(`[Admin] Deleting removed reward ID: ${existingId}`);
          await storage.deleteSpinReward(existingId);
        }
      });
      res.json({
        success: true,
        message: `${spinType} spin rewards updated successfully`,
        updatedRewards
      });
    } catch (err) {
      console.error("[Admin] Error updating spin rewards:", err);
      res.status(500).json({ error: "Failed to update spin rewards" });
    }
  });
  app2.post("/api/account/telegram-id", isAuthenticated, async (req, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const userId = req.user.id;
      const { telegramId } = req.body;
      if (!telegramId || typeof telegramId !== "string") {
        return res.status(400).json({ error: "Invalid Telegram ID format" });
      }
      await storage.updateUserTelegramId(userId, telegramId);
      res.json({
        success: true,
        message: "Telegram ID updated successfully"
      });
    } catch (error) {
      console.error("Error updating Telegram ID:", error);
      res.status(500).json({ error: "Failed to update Telegram ID" });
    }
  });
  app2.get("/api/admin/telegram-ids", isAuthenticated, async (req, res) => {
    try {
      if (!req.user) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      if (!req.user.isAdmin) {
        return res.status(403).json({ error: "Access denied" });
      }
      const users2 = await storage.getAllUsersTelegramIds();
      res.json(users2);
    } catch (error) {
      console.error("Error fetching Telegram IDs:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });
  app2.post("/api/admin/transactions/update", async (req, res) => {
    const schema = z3.object({
      transactionId: z3.string(),
      status: z3.enum(["completed", "rejected"])
    });
    const result = schema.safeParse(req.body);
    if (!result.success) return res.status(400).json(result.error);
    try {
      console.log(`[Admin] Updating transaction ${result.data.transactionId} to status: ${result.data.status}`);
      await storage.updateTransactionStatus(
        result.data.transactionId,
        result.data.status
      );
      const transaction = await storage.getTransactionByTransactionId(result.data.transactionId);
      if (!transaction) {
        console.error(`[Admin] Transaction not found: ${result.data.transactionId}`);
        return res.status(404).send("Transaction not found");
      }
      console.log(`[Admin] Found transaction:`, JSON.stringify(transaction));
      let isFirstDeposit = false;
      let bonusAmount = 0;
      if (result.data.status === "completed" && transaction.type === "recharge") {
        const finalAmount = parseFloat(transaction.amount);
        console.log(`[Admin] Processing approved recharge: $${finalAmount}`);
        await storage.updateUserBalance(transaction.userId, finalAmount);
        console.log(`[Admin] Added $${finalAmount} to user ${transaction.userId} balance`);
        let user;
        try {
          user = await storage.getUser(transaction.userId);
          console.log(`[Admin] Retrieved user:`, JSON.stringify(user));
        } catch (userLookupError) {
          console.error("[Admin] Error retrieving user:", userLookupError);
        }
        try {
          const userTransactions = await storage.getTransactionsByUserId(transaction.userId);
          console.log(`[Admin] Found ${userTransactions.length} transactions for user ${transaction.userId}`);
          const previousDeposits = userTransactions.filter(
            (t) => t.type === "recharge" && t.status === "completed" && t.id !== transaction.id
            // Exclude current transaction
          );
          isFirstDeposit = previousDeposits.length === 0;
          console.log(`[Admin] Is first deposit: ${isFirstDeposit}`);
          if (isFirstDeposit) {
            bonusAmount = finalAmount * 0.1;
            console.log(`[Admin] Applying first deposit bonus: $${bonusAmount}`);
            await storage.createTransaction(
              transaction.userId,
              "bonus",
              bonusAmount,
              `bonus-${transaction.transactionId}`,
              void 0,
              JSON.stringify({ reason: "First deposit bonus" })
            );
            await storage.updateUserBalance(transaction.userId, bonusAmount);
            console.log(`[Admin] Added bonus $${bonusAmount} to user ${transaction.userId} balance`);
          }
        } catch (depositCheckError) {
          console.error("[Admin] Error checking first deposit status:", depositCheckError);
        }
        if (user && user.referredBy) {
          try {
            console.log(`[Admin] User was referred by: ${user.referredBy}`);
            const referrer = await storage.getUserByReferralCode(user.referredBy);
            if (referrer) {
              console.log(`[Admin] Found referrer: ${referrer.id}`);
              const commission = finalAmount * 0.1;
              await storage.updateUserBalance(referrer.id, commission);
              await storage.updateUserReferralEarnings(referrer.id, commission);
              await storage.updateUserTeamEarnings(referrer.id, commission);
              console.log(`[Admin] Added commission $${commission} to referrer ${referrer.id}`);
              try {
                await storage.createReferralEarning({
                  userId: referrer.id,
                  referredUserId: transaction.userId,
                  level: 1,
                  // Direct referral level
                  amount: commission.toString(),
                  // Convert to string for decimal type
                  claimed: false
                });
                console.log(`[Admin] Created referral earning record`);
                let currentReferrer = referrer;
                for (let level = 2; level <= 6; level++) {
                  if (!currentReferrer.referredBy) break;
                  const nextReferrer = await storage.getUserByReferralCode(currentReferrer.referredBy);
                  if (!nextReferrer) break;
                  let commissionRate = 0;
                  switch (level) {
                    case 2:
                      commissionRate = referralCommissionRates.level2;
                      break;
                    // 6%
                    case 3:
                      commissionRate = referralCommissionRates.level3;
                      break;
                    // 4%
                    case 4:
                      commissionRate = referralCommissionRates.level4;
                      break;
                    // 3%
                    case 5:
                      commissionRate = referralCommissionRates.level5;
                      break;
                    // 2%
                    case 6:
                      commissionRate = referralCommissionRates.level6;
                      break;
                  }
                  const higherLevelCommission = finalAmount * commissionRate;
                  await storage.createReferralEarning({
                    userId: nextReferrer.id,
                    referredUserId: transaction.userId,
                    level,
                    amount: higherLevelCommission.toFixed(2),
                    claimed: false
                  });
                  await storage.updateUserReferralEarnings(nextReferrer.id, higherLevelCommission);
                  await storage.updateUserTeamEarnings(nextReferrer.id, higherLevelCommission);
                  console.log(`[Admin] Added level ${level} commission $${higherLevelCommission.toFixed(2)} to referrer ${nextReferrer.id}`);
                  currentReferrer = nextReferrer;
                }
              } catch (referralEarningError) {
                console.error("[Admin] Error creating referral earning:", referralEarningError);
              }
              if (!isFirstDeposit) {
                console.log(`[Admin] Double checking to ensure referral bonus is applied`);
                const userBonuses = await storage.getTransactionsByUserId(transaction.userId);
                const hasReceivedBonus = userBonuses.some((t) => t.type === "bonus" && t.status === "completed");
                if (!hasReceivedBonus) {
                  console.log(`[Admin] No prior bonus found, applying referral bonus`);
                  bonusAmount = finalAmount * 0.1;
                  await storage.createTransaction(
                    transaction.userId,
                    "bonus",
                    bonusAmount,
                    `bonus-ref-${transaction.transactionId}`,
                    void 0,
                    JSON.stringify({ reason: "Referral deposit bonus" })
                  );
                  await storage.updateUserBalance(transaction.userId, bonusAmount);
                  console.log(`[Admin] Added bonus $${bonusAmount} to referred user ${transaction.userId} balance`);
                  isFirstDeposit = true;
                }
              }
            }
          } catch (referralError) {
            console.error("[Admin] Error processing referral commissions:", referralError);
          }
        }
      }
      console.log(`[Admin] Transaction update completed successfully`);
      res.json({
        success: true,
        status: result.data.status,
        isFirstDeposit,
        bonusAmount,
        transactionId: transaction.transactionId
      });
    } catch (err) {
      console.error("[Admin] Error updating transaction:", err);
      if (err instanceof Error) {
        res.status(400).send(err.message);
      } else {
        res.status(400).send("Failed to update transaction");
      }
    }
  });
  app2.post("/api/admin/qrcode", async (req, res) => {
    const schema = z3.object({
      address: z3.string()
    });
    const result = schema.safeParse(req.body);
    if (!result.success) return res.status(400).json(result.error);
    try {
      await storage.updatePaymentAddress(result.data.address);
      res.json({ success: true });
    } catch (err) {
      if (err instanceof Error) {
        res.status(400).send(err.message);
      } else {
        res.status(400).send("Failed to update payment address");
      }
    }
  });
  app2.post("/api/admin/withdrawal-tax", async (req, res) => {
    const schema = z3.object({
      taxPercentage: z3.number().min(0).max(100)
    });
    const result = schema.safeParse(req.body);
    if (!result.success) return res.status(400).json(result.error);
    try {
      await storage.updateWithdrawalTax(result.data.taxPercentage);
      res.json({ success: true });
    } catch (err) {
      if (err instanceof Error) {
        res.status(400).send(err.message);
      } else {
        res.status(400).send("Failed to update withdrawal tax");
      }
    }
  });
  app2.post("/api/admin/update-referral-counts", async (req, res) => {
    try {
      console.log("[Admin Route] Updating referral counts for all users");
      await storage.updateReferralCounts();
      res.json({ success: true, message: "Referral counts updated successfully" });
    } catch (err) {
      if (err instanceof Error) {
        res.status(500).send(err.message);
      } else {
        res.status(500).send("Failed to update referral counts");
      }
    }
  });
  app2.get("/api/chickens", isAuthenticated, async (req, res) => {
    try {
      await storage.checkAndUpdateChickenStatus(req.user.id);
      const chickens2 = await storage.getChickensByUserId(req.user.id);
      res.json(chickens2);
    } catch (error) {
      console.error("Error fetching chickens:", error);
      res.status(500).json({ error: "Failed to fetch chickens" });
    }
  });
  app2.post("/api/chickens/buy", isAuthenticated, async (req, res) => {
    const schema = z3.object({ type: z3.enum(["baby", "regular", "golden"]) });
    const result = schema.safeParse(req.body);
    if (!result.success) return res.status(400).json(result.error);
    const prices2 = await storage.getPrices();
    const price = prices2.find((p) => p.itemType === `${result.data.type}_chicken`);
    if (!price) return res.status(400).send("Invalid chicken type");
    try {
      await storage.updateUserBalance(req.user.id, -parseFloat(price.price));
      const chicken = await storage.createChicken(req.user.id, result.data.type);
      res.json(chicken);
    } catch (err) {
      if (err instanceof Error) {
        res.status(400).send(err.message);
      } else {
        res.status(400).send("Failed to buy chicken");
      }
    }
  });
  app2.post("/api/chickens/:id/hatch", isAuthenticated, async (req, res) => {
    const chickenId = parseInt(req.params.id);
    const chickens2 = await storage.getChickensByUserId(req.user.id);
    const chicken = chickens2.find((c) => c.id === chickenId);
    if (!chicken) return res.status(404).send("Chicken not found");
    const resources2 = await storage.getResourcesByUserId(req.user.id);
    const resourceRequirements = {
      baby: { water: 1, wheat: 1, eggs: 2 },
      regular: { water: 2, wheat: 2, eggs: 5 },
      golden: { water: 10, wheat: 15, eggs: 20 }
    };
    const required = resourceRequirements[chicken.type];
    if (resources2.waterBuckets < required.water || resources2.wheatBags < required.wheat) {
      return res.status(400).send("Insufficient resources");
    }
    await storage.updateResources(req.user.id, {
      waterBuckets: resources2.waterBuckets - required.water,
      wheatBags: resources2.wheatBags - required.wheat,
      eggs: resources2.eggs + required.eggs
    });
    await storage.updateChickenHatchTime(chickenId);
    res.json({ success: true });
  });
  app2.post("/api/chickens/sell/:id", isAuthenticated, async (req, res) => {
    try {
      const chickenId = parseInt(req.params.id);
      const chickens2 = await storage.getChickensByUserId(req.user.id);
      const chicken = chickens2.find((c) => c.id === chickenId);
      if (!chicken) {
        return res.status(404).send("Chicken not found");
      }
      const prices2 = await storage.getPrices();
      const price = prices2.find((p) => p.itemType === `${chicken.type}_chicken`);
      if (!price) {
        return res.status(400).send("Invalid chicken type");
      }
      const sellPrice = parseFloat(price.price) * 0.75;
      await storage.deleteChicken(chickenId);
      await storage.updateUserBalance(req.user.id, sellPrice);
      await storage.createTransaction(
        req.user.id,
        "sale",
        sellPrice,
        void 0,
        void 0,
        JSON.stringify({ itemType: `${chicken.type}_chicken`, action: "sell" })
      );
      res.json({
        success: true,
        amount: sellPrice
      });
    } catch (err) {
      if (err instanceof Error) {
        res.status(400).send(err.message);
      } else {
        res.status(400).send("Failed to sell chicken");
      }
    }
  });
  app2.get("/api/chickens/counts", async (req, res) => {
    try {
      const counts = await storage.getChickenCountsByType();
      res.json(counts);
    } catch (err) {
      if (err instanceof Error) {
        res.status(500).send(err.message);
      } else {
        res.status(500).send("Failed to get chicken counts");
      }
    }
  });
  app2.get("/api/resources", isAuthenticated, async (req, res) => {
    try {
      const resources2 = await storage.getResourcesByUserId(req.user.id);
      res.json(resources2);
    } catch (err) {
      try {
        const defaultResource = await storage.updateResources(req.user.id, {
          waterBuckets: 0,
          wheatBags: 0,
          eggs: 0
        });
        res.json(defaultResource);
      } catch (err2) {
        res.status(500).json({ error: "Failed to create resources" });
      }
    }
  });
  app2.get("/api/prices", async (req, res) => {
    const prices2 = await storage.getPrices();
    res.json(prices2);
  });
  app2.post("/api/market/buy", isAuthenticated, async (req, res) => {
    const schema = z3.object({
      itemType: z3.enum(["water_bucket", "wheat_bag"]),
      quantity: z3.number().positive()
    });
    const result = schema.safeParse(req.body);
    if (!result.success) return res.status(400).json(result.error);
    const prices2 = await storage.getPrices();
    const price = prices2.find((p) => p.itemType === result.data.itemType);
    if (!price) return res.status(400).send("Invalid item type");
    const totalCost = parseFloat(price.price) * result.data.quantity;
    try {
      await storage.updateUserBalance(req.user.id, -totalCost);
      const resources2 = await storage.getResourcesByUserId(req.user.id);
      const updates = result.data.itemType === "water_bucket" ? { waterBuckets: resources2.waterBuckets + result.data.quantity } : { wheatBags: resources2.wheatBags + result.data.quantity };
      await storage.updateResources(req.user.id, updates);
      res.json({ success: true });
    } catch (err) {
      if (err instanceof Error) {
        res.status(400).send(err.message);
      } else {
        res.status(400).send("Failed to buy resource");
      }
    }
  });
  app2.post("/api/market/sell", isAuthenticated, async (req, res) => {
    const schema = z3.object({
      quantity: z3.number().positive()
    });
    const result = schema.safeParse(req.body);
    if (!result.success) return res.status(400).json(result.error);
    const resources2 = await storage.getResourcesByUserId(req.user.id);
    if (resources2.eggs < result.data.quantity) {
      return res.status(400).send("Insufficient eggs");
    }
    const prices2 = await storage.getPrices();
    const price = prices2.find((p) => p.itemType === "egg");
    if (!price) return res.status(400).send("Egg price not found");
    const totalEarnings = parseFloat(price.price) * result.data.quantity;
    try {
      await storage.updateUserBalance(req.user.id, totalEarnings);
      await storage.updateResources(req.user.id, {
        eggs: resources2.eggs - result.data.quantity
      });
      res.json({ success: true });
    } catch (err) {
      if (err instanceof Error) {
        res.status(400).send(err.message);
      } else {
        res.status(400).send("Failed to sell eggs");
      }
    }
  });
  app2.get("/api/transactions", isAuthenticated, async (req, res) => {
    const transactions2 = await storage.getTransactionsByUserId(req.user.id);
    res.json(transactions2);
  });
  app2.post("/api/wallet/recharge", isAuthenticated, async (req, res) => {
    console.log(`[Wallet] ===== PAYMENT REQUEST STARTED =====`);
    console.log(`[Wallet] Request body:`, req.body);
    const schema = z3.object({
      amount: z3.number().positive(),
      currency: z3.string().optional().default("USDT")
    });
    const result = schema.safeParse(req.body);
    if (!result.success) {
      console.error(`[Wallet] Invalid request body:`, req.body);
      console.error(`[Wallet] Validation error:`, result.error);
      return res.status(400).json(result.error);
    }
    try {
      console.log(`[Wallet] Processing deposit request for $${result.data.amount} from user ${req.user.id}`);
      return res.status(503).json({
        error: "Payment Processing Disabled",
        message: "The payment processing feature has been disabled in this application. Please contact support for alternative payment options.",
        status: "disabled"
      });
    } catch (err) {
      console.error("[Wallet] Error:", err);
      return res.status(500).json({
        error: "Payment Processing Error",
        message: "There was an error processing your payment request. Please try again later or contact support."
      });
    }
  });
  app2.post("/api/wallet/withdraw", isAuthenticated, async (req, res) => {
    const schema = z3.object({
      amount: z3.number().positive(),
      usdtAddress: z3.string().min(5).max(100)
    });
    const result = schema.safeParse(req.body);
    if (!result.success) return res.status(400).json(result.error);
    try {
      await storage.updateUserBalance(req.user.id, -result.data.amount);
      const usdtAddressData = JSON.stringify({ usdtAddress: result.data.usdtAddress });
      const transactionId = `W${Date.now()}${Math.floor(Math.random() * 1e3)}`;
      const transaction = await storage.createTransaction(
        req.user.id,
        "withdrawal",
        result.data.amount,
        transactionId,
        void 0,
        usdtAddressData
      );
      res.json(transaction);
    } catch (err) {
      if (err instanceof Error) {
        res.status(400).send(err.message);
      } else {
        res.status(400).send("Failed to process withdrawal");
      }
    }
  });
  app2.get("/api/mystery-box/count", isAuthenticated, async (req, res) => {
    try {
      const resources2 = await storage.getResourcesByUserId(req.user.id);
      console.log(`[MysteryBox] Current box count for user ${req.user.id}:`, resources2.mysteryBoxes);
      res.json({ count: resources2.mysteryBoxes || 0 });
    } catch (err) {
      console.error("[MysteryBox] Error fetching box count:", err);
      res.status(500).json({ error: "Failed to fetch mystery boxes" });
    }
  });
  app2.post("/api/mystery-box/buy", isAuthenticated, async (req, res) => {
    const schema = z3.object({
      boxType: z3.enum(["basic", "standard", "advanced", "legendary"])
    });
    const result = schema.safeParse(req.body);
    if (!result.success) return res.status(400).json(result.error);
    try {
      console.log(`[MysteryBox] Buying box type: ${result.data.boxType} for user ${req.user.id}`);
      await storage.purchaseMysteryBox(req.user.id, result.data.boxType);
      const boxConfig = mysteryBoxTypes2[result.data.boxType];
      res.json({
        success: true,
        boxType: result.data.boxType,
        price: boxConfig.price
      });
    } catch (err) {
      console.error("[MysteryBox] Error purchasing box:", err);
      if (err instanceof Error) {
        res.status(400).send(err.message);
      } else {
        res.status(400).send("Failed to purchase mystery box");
      }
    }
  });
  app2.post("/api/mystery-box/open", isAuthenticated, async (req, res) => {
    const schema = z3.object({
      boxType: z3.enum(["basic", "standard", "advanced", "legendary"]).optional()
    });
    const result = schema.safeParse(req.body);
    if (!result.success) return res.status(400).json(result.error);
    try {
      console.log(`[MysteryBox] Opening box for user ${req.user.id}, type:`, result.data.boxType);
      const reward = await storage.openMysteryBox(req.user.id, result.data.boxType || "basic");
      if (!reward) {
        console.error("[MysteryBox] Failed to generate reward");
        return res.status(400).send("Failed to open mystery box");
      }
      console.log(`[MysteryBox] Successfully opened box, reward:`, reward);
      res.json({
        success: true,
        reward
      });
    } catch (err) {
      console.error("[MysteryBox] Error opening box:", err);
      if (err instanceof Error) {
        res.status(400).send(err.message);
      } else {
        res.status(400).send("Failed to open mystery box");
      }
    }
  });
  app2.get("/api/mystery-box/rewards", isAuthenticated, async (req, res) => {
    try {
      const rewards = await storage.getMysteryBoxRewardsByUserId(req.user.id);
      console.log(`[MysteryBox] Retrieved rewards for user ${req.user.id}:`, rewards.length);
      res.json(rewards);
    } catch (err) {
      console.error("[MysteryBox] Error fetching rewards:", err);
      res.status(500).json({ error: "Failed to fetch mystery box rewards" });
    }
  });
  app2.post("/api/mystery-box/claim/:id", isAuthenticated, async (req, res) => {
    try {
      const rewardId = parseInt(req.params.id);
      if (isNaN(rewardId)) {
        console.error("[MysteryBox] Invalid reward ID:", req.params.id);
        return res.status(400).send("Invalid reward ID");
      }
      console.log(`[MysteryBox] Claiming reward ${rewardId} for user ${req.user.id}`);
      const claimedReward = await storage.claimMysteryBoxReward(rewardId);
      console.log(`[MysteryBox] Successfully claimed reward:`, claimedReward);
      res.json({
        success: true,
        reward: claimedReward
      });
    } catch (err) {
      console.error("[MysteryBox] Error claiming reward:", err);
      if (err instanceof Error) {
        res.status(400).send(err.message);
      } else {
        res.status(400).send("Failed to claim reward");
      }
    }
  });
  app2.get("/api/referrals", isAuthenticated, async (req, res) => {
    try {
      const directReferrals = await storage.getUserReferrals(req.user.id);
      res.json(directReferrals);
    } catch (err) {
      console.error("Error getting referrals:", err);
      res.status(500).json({ error: "Failed to get referrals" });
    }
  });
  app2.get("/api/referrals/earnings", isAuthenticated, async (req, res) => {
    try {
      const earnings = await storage.getReferralEarningsByUserId(req.user.id);
      res.json(earnings);
    } catch (err) {
      console.error("Error getting referral earnings:", err);
      res.status(500).json({ error: "Failed to get referral earnings" });
    }
  });
  app2.get("/api/referrals/earnings/unclaimed", isAuthenticated, async (req, res) => {
    try {
      const unclaimedEarnings = await storage.getUnclaimedReferralEarnings(req.user.id);
      res.json(unclaimedEarnings);
    } catch (err) {
      console.error("Error getting unclaimed referral earnings:", err);
      res.status(500).json({ error: "Failed to get unclaimed referral earnings" });
    }
  });
  app2.post("/api/referrals/earnings/:id/claim", isAuthenticated, async (req, res) => {
    try {
      const earningId = parseInt(req.params.id);
      const claimed = await storage.claimReferralEarning(earningId);
      res.json({
        success: true,
        claimed
      });
    } catch (err) {
      if (err instanceof Error) {
        res.status(400).send(err.message);
      } else {
        res.status(400).send("Failed to claim referral earning");
      }
    }
  });
  app2.get("/api/milestones", isAuthenticated, async (req, res) => {
    try {
      const milestones = await storage.getMilestoneRewardsByUserId(req.user.id);
      res.json(milestones);
    } catch (err) {
      console.error("Error getting milestone rewards:", err);
      res.status(500).json({ error: "Failed to get milestone rewards" });
    }
  });
  app2.get("/api/milestones/unclaimed", isAuthenticated, async (req, res) => {
    try {
      const unclaimedMilestones = await storage.getUnclaimedMilestoneRewards(req.user.id);
      res.json(unclaimedMilestones);
    } catch (err) {
      console.error("Error getting unclaimed milestone rewards:", err);
      res.status(500).json({ error: "Failed to get unclaimed milestone rewards" });
    }
  });
  app2.post("/api/milestones/:id/claim", isAuthenticated, async (req, res) => {
    try {
      const milestoneId = parseInt(req.params.id);
      const claimed = await storage.claimMilestoneReward(milestoneId);
      res.json({
        success: true,
        claimed
      });
    } catch (err) {
      if (err instanceof Error) {
        res.status(400).send(err.message);
      } else {
        res.status(400).send("Failed to claim milestone reward");
      }
    }
  });
  app2.get("/api/salary/payments", isAuthenticated, async (req, res) => {
    try {
      const payments = await storage.getSalaryPaymentsByUserId(req.user.id);
      res.json(payments);
    } catch (err) {
      console.error("Error getting salary payments:", err);
      res.status(500).json({ error: "Failed to get salary payments" });
    }
  });
  app2.get("/api/rewards/daily", isAuthenticated, async (req, res) => {
    try {
      const reward = await storage.getCurrentDailyReward(req.user.id);
      res.json(reward);
    } catch (err) {
      console.error("Error getting daily reward:", err);
      res.status(500).json({ error: "Failed to get daily reward" });
    }
  });
  app2.get("/api/rewards/daily/history", isAuthenticated, async (req, res) => {
    try {
      const rewards = await storage.getDailyRewardsByUserId(req.user.id);
      res.json(rewards);
    } catch (err) {
      console.error("Error getting daily rewards history:", err);
      res.status(500).json({ error: "Failed to get daily rewards history" });
    }
  });
  app2.post("/api/rewards/daily/:id/claim", isAuthenticated, async (req, res) => {
    try {
      const rewardId = parseInt(req.params.id);
      const claimed = await storage.claimDailyReward(rewardId);
      res.json({
        success: true,
        claimed
      });
    } catch (err) {
      if (err instanceof Error) {
        res.status(400).send(err.message);
      } else {
        res.status(400).send("Failed to claim daily reward");
      }
    }
  });
  app2.get("/api/boosts", isAuthenticated, async (req, res) => {
    try {
      const boosts = await storage.getActiveBoostsByUserId(req.user.id);
      const eggMultiplier = await storage.getActiveEggBoost(req.user.id);
      res.json({
        boosts,
        eggMultiplier
      });
    } catch (err) {
      console.error("Error getting active boosts:", err);
      res.status(500).json({ error: "Failed to get active boosts" });
    }
  });
  app2.post("/api/wallet/recharge/complete", isAuthenticated, async (req, res) => {
    console.log("[Wallet] Manual recharge completion request");
    const schema = z3.object({
      transactionId: z3.string()
    });
    const result = schema.safeParse(req.body);
    if (!result.success) return res.status(400).json(result.error);
    try {
      const transaction = await storage.getTransactionByTransactionId(result.data.transactionId);
      if (!transaction) {
        return res.status(404).send("Transaction not found");
      }
      await storage.updateTransactionStatus(result.data.transactionId, "completed");
      const userTransactions = await storage.getTransactionsByUserId(req.user.id);
      const previousDeposits = userTransactions.filter((t) => t.type === "recharge" && t.status === "completed");
      const isFirstDeposit = previousDeposits.length === 0;
      let finalAmount = parseFloat(transaction.amount);
      let bonusAmount = 0;
      if (isFirstDeposit) {
        bonusAmount = finalAmount * 0.1;
        finalAmount += bonusAmount;
        await storage.createTransaction(
          req.user.id,
          "bonus",
          bonusAmount,
          `bonus-${transaction.transactionId}`,
          void 0,
          JSON.stringify({ reason: "First deposit bonus" })
        );
        await storage.updateTransactionStatus(`bonus-${transaction.transactionId}`, "completed");
        await storage.updateUserBalance(req.user.id, bonusAmount);
      }
      await storage.updateUserBalance(req.user.id, parseFloat(transaction.amount));
      const user = await storage.getUser(req.user.id);
      if (user && user.referredBy) {
        try {
          const referrer = await storage.getUserByReferralCode(user.referredBy);
          if (referrer) {
            const level1Amount = parseFloat(transaction.amount) * 0.1;
            await storage.createReferralEarning({
              userId: referrer.id,
              referredUserId: req.user.id,
              level: 1,
              amount: level1Amount.toFixed(2),
              claimed: false
            });
            await storage.updateUserReferralEarnings(referrer.id, level1Amount);
            await storage.updateUserTeamEarnings(referrer.id, level1Amount);
            let currentReferrer = referrer;
            for (let level = 2; level <= 6; level++) {
              if (!currentReferrer.referredBy) break;
              const nextReferrer = await storage.getUserByReferralCode(currentReferrer.referredBy);
              if (!nextReferrer) break;
              let commissionRate = 0;
              switch (level) {
                case 2:
                  commissionRate = referralCommissionRates.level2;
                  break;
                // 6%
                case 3:
                  commissionRate = referralCommissionRates.level3;
                  break;
                // 4%
                case 4:
                  commissionRate = referralCommissionRates.level4;
                  break;
                // 3%
                case 5:
                  commissionRate = referralCommissionRates.level5;
                  break;
                // 2%
                case 6:
                  commissionRate = referralCommissionRates.level6;
                  break;
              }
              const commissionAmount = parseFloat(transaction.amount) * commissionRate;
              await storage.createReferralEarning({
                userId: nextReferrer.id,
                referredUserId: req.user.id,
                level,
                amount: commissionAmount.toFixed(2),
                claimed: false
              });
              await storage.updateUserReferralEarnings(nextReferrer.id, commissionAmount);
              await storage.updateUserTeamEarnings(nextReferrer.id, commissionAmount);
              currentReferrer = nextReferrer;
            }
          }
        } catch (referralError) {
          console.error("Error processing referral commissions:", referralError);
        }
      }
      res.json({
        success: true,
        isFirstDeposit,
        bonusAmount,
        totalAmount: finalAmount
      });
    } catch (err) {
      if (err instanceof Error) {
        res.status(400).send(err.message);
      } else {
        res.status(400).send("Failed to complete recharge");
      }
    }
  });
  app2.get("/api/spin/status", isAuthenticated, async (req, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user) {
        return res.status(404).send("User not found");
      }
      const lastSpinTime = user.lastSpinAt ? new Date(user.lastSpinAt) : null;
      const now = /* @__PURE__ */ new Date();
      const nextMidnightUTC = new Date(now);
      nextMidnightUTC.setUTCHours(24, 0, 0, 0);
      const canSpinDaily = !lastSpinTime || lastSpinTime < new Date(now.setUTCHours(0, 0, 0, 0));
      const timeUntilNextSpin = canSpinDaily ? 0 : nextMidnightUTC.getTime() - now.getTime();
      res.json({
        canSpinDaily,
        timeUntilNextSpin,
        extraSpinsAvailable: user.extraSpinsAvailable || 0
      });
    } catch (err) {
      console.error("Error getting spin status:", err);
      res.status(500).json({ error: "Failed to get spin status" });
    }
  });
  app2.post("/api/spin/daily", isAuthenticated, async (req, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user) {
        return res.status(404).send("User not found");
      }
      const now = /* @__PURE__ */ new Date();
      const lastSpinTime = user.lastSpinAt ? new Date(user.lastSpinAt) : null;
      const canSpinDaily = !lastSpinTime || lastSpinTime < new Date(now.setUTCHours(0, 0, 0, 0));
      if (!canSpinDaily && user.extraSpinsAvailable === 0) {
        return res.status(400).send("No spins available");
      }
      const totalProbability = dailySpinRewards.reduce((sum, reward) => sum + reward.probability, 0);
      let random = Math.random() * totalProbability;
      let selectedReward = dailySpinRewards[0];
      for (const reward of dailySpinRewards) {
        random -= reward.probability;
        if (random <= 0) {
          selectedReward = reward;
          break;
        }
      }
      const spinRecord = await storage.createSpinHistory({
        userId: req.user.id,
        spinType: "daily",
        rewardType: selectedReward.reward.type,
        rewardAmount: selectedReward.reward.amount.toString(),
        // Convert to string for decimal type
        chickenType: selectedReward.reward.chickenType
      });
      switch (selectedReward.reward.type) {
        case "eggs": {
          const resources2 = await storage.getResourcesByUserId(req.user.id);
          await storage.updateResources(req.user.id, {
            eggs: resources2.eggs + selectedReward.reward.amount
          });
          break;
        }
        case "wheat": {
          const resources2 = await storage.getResourcesByUserId(req.user.id);
          await storage.updateResources(req.user.id, {
            wheatBags: resources2.wheatBags + selectedReward.reward.amount
          });
          break;
        }
        case "water": {
          const resources2 = await storage.getResourcesByUserId(req.user.id);
          await storage.updateResources(req.user.id, {
            waterBuckets: resources2.waterBuckets + selectedReward.reward.amount
          });
          break;
        }
        case "usdt": {
          await storage.updateUserBalance(req.user.id, selectedReward.reward.amount);
          break;
        }
        case "extra_spin": {
          await storage.updateUserExtraSpins(req.user.id, user.extraSpinsAvailable + selectedReward.reward.amount);
          break;
        }
      }
      if (canSpinDaily) {
        await storage.updateUserLastSpin(req.user.id);
      } else {
        await storage.updateUserExtraSpins(req.user.id, user.extraSpinsAvailable - 1);
      }
      res.json({
        success: true,
        reward: selectedReward.reward,
        spinRecord
      });
    } catch (err) {
      console.error("Error processing daily spin:", err);
      if (err instanceof Error) {
        res.status(400).send(err.message);
      } else {
        res.status(400).send("Failed to process daily spin");
      }
    }
  });
  app2.post("/api/spin/super", isAuthenticated, async (req, res) => {
    try {
      const SUPER_SPIN_COST = 10;
      const user = await storage.getUser(req.user.id);
      if (!user) {
        return res.status(404).send("User not found");
      }
      if (parseFloat(user.usdtBalance) < SUPER_SPIN_COST) {
        return res.status(400).send("Insufficient USDT balance");
      }
      await storage.updateUserBalance(req.user.id, -SUPER_SPIN_COST);
      const totalProbability = superJackpotRewards.reduce((sum, reward) => sum + reward.probability, 0);
      let random = Math.random() * totalProbability;
      let selectedReward = superJackpotRewards[0];
      for (const reward of superJackpotRewards) {
        random -= reward.probability;
        if (random <= 0) {
          selectedReward = reward;
          break;
        }
      }
      const spinRecord = await storage.createSpinHistory({
        userId: req.user.id,
        spinType: "super",
        rewardType: selectedReward.reward.type,
        rewardAmount: selectedReward.reward.amount.toString(),
        // Convert to string for decimal type
        chickenType: selectedReward.reward.chickenType
      });
      switch (selectedReward.reward.type) {
        case "eggs": {
          const resources2 = await storage.getResourcesByUserId(req.user.id);
          await storage.updateResources(req.user.id, {
            eggs: resources2.eggs + selectedReward.reward.amount
          });
          break;
        }
        case "usdt": {
          await storage.updateUserBalance(req.user.id, selectedReward.reward.amount);
          break;
        }
        case "chicken": {
          if (selectedReward.reward.chickenType) {
            await storage.createChicken(req.user.id, selectedReward.reward.chickenType);
            if (selectedReward.reward.amount > 1) {
              await storage.updateUserBalance(req.user.id, 50);
            }
          }
          break;
        }
      }
      res.json({
        success: true,
        reward: selectedReward.reward,
        spinRecord
      });
    } catch (err) {
      console.error("Error processing super spin:", err);
      if (err instanceof Error) {
        res.status(400).send(err.message);
      } else {
        res.status(400).send("Failed to process super spin");
      }
    }
  });
  app2.get("/api/spin/history", isAuthenticated, async (req, res) => {
    try {
      const history = await storage.getSpinHistoryByUserId(req.user.id);
      res.json(history);
    } catch (err) {
      console.error("Error getting spin history:", err);
      res.status(500).json({ error: "Failed to get spin history" });
    }
  });
  app2.post("/api/spin/buy", isAuthenticated, async (req, res) => {
    try {
      const EXTRA_SPIN_COST = 2;
      const schema = z3.object({
        quantity: z3.number().positive()
      });
      const result = schema.safeParse(req.body);
      if (!result.success) return res.status(400).json(result.error);
      const totalCost = EXTRA_SPIN_COST * result.data.quantity;
      const user = await storage.getUser(req.user.id);
      if (!user) {
        return res.status(404).send("User not found");
      }
      if (parseFloat(user.usdtBalance) < totalCost) {
        return res.status(400).send("Insufficient USDT balance");
      }
      await storage.updateUserBalance(req.user.id, -totalCost);
      await storage.updateUserExtraSpins(req.user.id, (user.extraSpinsAvailable || 0) + result.data.quantity);
      res.json({
        success: true,
        extraSpinsAdded: result.data.quantity,
        totalCost
      });
    } catch (err) {
      console.error("Error buying extra spins:", err);
      if (err instanceof Error) {
        res.status(400).send(err.message);
      } else {
        res.status(400).send("Failed to buy extra spins");
      }
    }
  });
  app2.get("/api/tutorial/status", isAuthenticated, async (req, res) => {
    try {
      if (!req.user || !req.user.id) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const userProfile = await storage.getUserProfile(req.user.id);
      if (!userProfile) {
        return res.status(404).json({ error: "User profile not found" });
      }
      res.json({
        tutorialStep: userProfile.tutorialStep,
        tutorialCompleted: userProfile.tutorialCompleted,
        tutorialDisabled: userProfile.tutorialDisabled
      });
    } catch (err) {
      console.error("Error fetching tutorial status:", err);
      res.status(500).json({ error: "Failed to fetch tutorial status" });
    }
  });
  app2.post("/api/tutorial/update-step", isAuthenticated, async (req, res) => {
    try {
      if (!req.user || !req.user.id) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const { step } = req.body;
      if (typeof step !== "number" || step < 0) {
        return res.status(400).json({ error: "Invalid tutorial step" });
      }
      const updatedProfile = await storage.updateTutorialProgress(req.user.id, step);
      res.json({
        tutorialStep: updatedProfile.tutorialStep,
        tutorialCompleted: updatedProfile.tutorialCompleted,
        tutorialDisabled: updatedProfile.tutorialDisabled
      });
    } catch (err) {
      console.error("Error updating tutorial step:", err);
      res.status(500).json({ error: "Failed to update tutorial step" });
    }
  });
  app2.post("/api/tutorial/complete", isAuthenticated, async (req, res) => {
    try {
      if (!req.user || !req.user.id) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const updatedProfile = await storage.completeTutorial(req.user.id);
      res.json({
        tutorialStep: updatedProfile.tutorialStep,
        tutorialCompleted: updatedProfile.tutorialCompleted,
        tutorialDisabled: updatedProfile.tutorialDisabled
      });
    } catch (err) {
      console.error("Error completing tutorial:", err);
      res.status(500).json({ error: "Failed to complete tutorial" });
    }
  });
  app2.post("/api/tutorial/disable", isAuthenticated, async (req, res) => {
    try {
      if (!req.user || !req.user.id) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const updatedProfile = await storage.disableTutorial(req.user.id);
      res.json({
        tutorialStep: updatedProfile.tutorialStep,
        tutorialCompleted: updatedProfile.tutorialCompleted,
        tutorialDisabled: updatedProfile.tutorialDisabled
      });
    } catch (err) {
      console.error("Error disabling tutorial:", err);
      res.status(500).json({ error: "Failed to disable tutorial" });
    }
  });
  const httpServer = createServer(app2);
  return httpServer;
}

// server/vite.ts
import express from "express";
import fs from "fs";
import path2, { dirname as dirname2 } from "path";
import { fileURLToPath as fileURLToPath2 } from "url";
import { createServer as createViteServer, createLogger } from "vite";

// vite.config.ts
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import themePlugin from "@replit/vite-plugin-shadcn-theme-json";
import path, { dirname } from "path";
import runtimeErrorOverlay from "@replit/vite-plugin-runtime-error-modal";
import { fileURLToPath } from "url";
var __filename = fileURLToPath(import.meta.url);
var __dirname2 = dirname(__filename);
var vite_config_default = defineConfig({
  plugins: [
    react(),
    runtimeErrorOverlay(),
    themePlugin(),
    ...process.env.NODE_ENV !== "production" && process.env.REPL_ID !== void 0 ? [
      await import("@replit/vite-plugin-cartographer").then(
        (m) => m.cartographer()
      )
    ] : []
  ],
  resolve: {
    alias: {
      "@": path.resolve(__dirname2, "client", "src"),
      "@shared": path.resolve(__dirname2, "shared")
    }
  },
  root: path.resolve(__dirname2, "client"),
  build: {
    outDir: path.resolve(__dirname2, "dist/public"),
    emptyOutDir: true
  }
});

// server/vite.ts
import { nanoid } from "nanoid";
var __filename2 = fileURLToPath2(import.meta.url);
var __dirname3 = dirname2(__filename2);
var viteLogger = createLogger();
function log(message, source = "express") {
  const formattedTime = (/* @__PURE__ */ new Date()).toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true
  });
  console.log(`${formattedTime} [${source}] ${message}`);
}
async function setupVite(app2, server) {
  const serverOptions = {
    middlewareMode: true,
    hmr: { server },
    allowedHosts: true
  };
  const vite = await createViteServer({
    ...vite_config_default,
    configFile: false,
    customLogger: {
      ...viteLogger,
      error: (msg, options) => {
        viteLogger.error(msg, options);
        process.exit(1);
      }
    },
    server: serverOptions,
    appType: "custom"
  });
  app2.use(vite.middlewares);
  app2.use("*", async (req, res, next) => {
    const url = req.originalUrl;
    try {
      const clientTemplate = path2.resolve(
        __dirname3,
        "..",
        "client",
        "index.html"
      );
      let template = await fs.promises.readFile(clientTemplate, "utf-8");
      template = template.replace(
        `src="/src/main.tsx"`,
        `src="/src/main.tsx?v=${nanoid()}"`
      );
      const page = await vite.transformIndexHtml(url, template);
      res.status(200).set({ "Content-Type": "text/html" }).end(page);
    } catch (e) {
      vite.ssrFixStacktrace(e);
      next(e);
    }
  });
}
function serveStatic(app2) {
  const distPath = path2.resolve(__dirname3, "public");
  if (!fs.existsSync(distPath)) {
    throw new Error(
      `Could not find the build directory: ${distPath}, make sure to build the client first`
    );
  }
  app2.use(express.static(distPath));
  app2.use("*", (_req, res) => {
    res.sendFile(path2.resolve(distPath, "index.html"));
  });
}

// server/routes-achievements.ts
import express2 from "express";
var router = express2.Router();
router.get("/badges", async (req, res) => {
  try {
    const badges = await storage.getAllAchievementBadges();
    res.json(badges);
  } catch (error) {
    console.error("[API] Error getting achievement badges:", error);
    res.status(500).json({ error: "Failed to get achievement badges" });
  }
});
router.get("/user", isAuthenticated, async (req, res) => {
  try {
    const userId = req.user.id;
    const achievements = await storage.getUserAchievements(userId);
    res.json(achievements);
  } catch (error) {
    console.error("[API] Error getting user achievements:", error);
    res.status(500).json({ error: "Failed to get user achievements" });
  }
});
router.get("/user/completed", isAuthenticated, async (req, res) => {
  try {
    const userId = req.user.id;
    const achievements = await storage.getCompletedUserAchievements(userId);
    res.json(achievements);
  } catch (error) {
    console.error("[API] Error getting completed achievements:", error);
    res.status(500).json({ error: "Failed to get completed achievements" });
  }
});
router.post("/progress/:code", isAuthenticated, async (req, res) => {
  try {
    const userId = req.user.id;
    const { code } = req.params;
    const { progress } = req.body;
    if (typeof progress !== "number") {
      return res.status(400).json({ error: "Progress must be a number" });
    }
    const badge = await storage.getAchievementBadgeByCode(code);
    if (!badge) {
      return res.status(404).json({ error: "Achievement badge not found" });
    }
    let userAchievement = await storage.getUserAchievementsByBadgeId(userId, badge.id);
    if (!userAchievement) {
      userAchievement = await storage.createUserAchievement({
        userId,
        badgeId: badge.id,
        progress,
        isComplete: progress >= badge.threshold
      });
    } else {
      const newProgress = Math.max(userAchievement.progress, progress);
      const isComplete = newProgress >= badge.threshold;
      userAchievement = await storage.updateUserAchievement(userAchievement.id, {
        progress: newProgress,
        isComplete,
        unlockedAt: isComplete && !userAchievement.isComplete ? /* @__PURE__ */ new Date() : userAchievement.unlockedAt
      });
    }
    res.json(userAchievement);
  } catch (error) {
    console.error("[API] Error progressing achievement:", error);
    res.status(500).json({ error: "Failed to progress achievement" });
  }
});
var routes_achievements_default = router;

// server/index.ts
import cors from "cors";
import * as pathModule from "path";
var app = express3();
app.use(cors({
  origin: process.env.NODE_ENV === "production" ? ["https://chickfarms.replit.app", "https://chickfarms.com"] : true,
  credentials: true
}));
app.use(express3.json());
app.use(express3.urlencoded({ extended: false }));
app.use((req, res, next) => {
  const start = Date.now();
  const reqPath = req.path;
  let capturedJsonResponse = void 0;
  const originalResJson = res.json;
  res.json = function(bodyJson, ...args) {
    capturedJsonResponse = bodyJson;
    return originalResJson.apply(res, [bodyJson, ...args]);
  };
  res.on("finish", () => {
    const duration = Date.now() - start;
    if (reqPath.startsWith("/api")) {
      let logLine = `${req.method} ${reqPath} ${res.statusCode} in ${duration}ms`;
      if (capturedJsonResponse) {
        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
      }
      if (logLine.length > 80) {
        logLine = logLine.slice(0, 79) + "\u2026";
      }
      log(logLine);
    }
  });
  next();
});
(async () => {
  app.use("/api", (req, res, next) => {
    res.setHeader("Content-Type", "application/json");
    res.setHeader("Access-Control-Allow-Origin", "*");
    res.setHeader("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
    res.setHeader("Access-Control-Allow-Headers", "Content-Type, Authorization");
    if (req.method === "OPTIONS") {
      return res.status(200).end();
    }
    next();
  });
  const server = await registerRoutes2(app);
  await registerRoutes(app);
  app.use("/api/achievements", routes_achievements_default);
  app.use((err, _req, res, _next) => {
    const status = err.status || err.statusCode || 500;
    const message = err.message || "Internal Server Error";
    console.error("Server error:", err);
    res.status(status).json({ message });
  });
  app.get("/test", (req, res) => {
    res.json({ status: "ok", message: "Server is working!" });
  });
  app.get("/health", (req, res) => {
    res.status(200).json({ status: "healthy" });
  });
  app.get("/api/debug", (req, res) => {
    res.json({
      message: "API is working",
      env: process.env.NODE_ENV,
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      headers: req.headers
    });
  });
  if (app.get("env") === "development") {
    await setupVite(app, server);
  } else {
    serveStatic(app);
  }
  const port = process.env.PORT ? parseInt(process.env.PORT, 10) : 5e3;
  console.log("Starting server on port", port);
  console.log("Current environment:", process.env.NODE_ENV);
  app.get("/", (req, res) => {
    res.sendFile(pathModule.join(__dirname, "../client/public/index.html"));
  });
  app.get(/^(?!\/api\/).*$/, (req, res, next) => {
    if (req.headers.accept && req.headers.accept.includes("text/html")) {
      return next();
    }
    express3.static(pathModule.join(__dirname, "../client/public"))(req, res, next);
  });
  server.listen(port, "0.0.0.0", () => {
    log(`serving on port ${port}`);
    console.log(`Server is listening on http://0.0.0.0:${port}`);
    console.log(`Environment: ${app.get("env")}`);
    const replSlug = process.env.REPL_SLUG;
    const replOwner = process.env.REPL_OWNER;
    if (replSlug && replOwner) {
      console.log(`Open in browser: https://${replSlug}.${replOwner}.repl.co`);
    } else {
      console.log(`Open in browser: http://localhost:${port}`);
    }
    console.log("Server initialization complete!");
    console.log("API route example: http://0.0.0.0:" + port + "/api/debug");
  });
})();